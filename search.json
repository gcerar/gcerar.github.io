[
  {
    "objectID": "posts/2023-10-10-vanilla-GANs/index.html",
    "href": "posts/2023-10-10-vanilla-GANs/index.html",
    "title": "Generative Adversarial Networks",
    "section": "",
    "text": "Generative Adversarial Networks (GANs) are an innovative class of unsupervised neural networks that have revolutionized the field of artificial intelligence. They were first introduced in Generative Adversarial Networks (Goodfellow et al. 2014) and consist of two separate neural networks: the generator (creates data) and the discriminator (evaluates data authenticity). The generator aims to fool the discriminator by producing realistic data, while the discriminator tries to differentiate real from fake. Over iterations, the generator’s data becomes more convincing.\nAs an analogy, consider two kids, one drawing counterfeit money (“Generator”) and another assessing its realism (“Discriminator”). Over time, the counterfeit drawings become increasingly convincing."
  },
  {
    "objectID": "posts/2023-10-10-vanilla-GANs/index.html#objective-function",
    "href": "posts/2023-10-10-vanilla-GANs/index.html#objective-function",
    "title": "Generative Adversarial Networks",
    "section": "Objective Function",
    "text": "Objective Function\nThe interaction between the Generator and the Discriminator can be quantified by their objective or loss functions:\n\nDiscriminator’s Objective: For real data \\(x\\), \\(D\\) wants \\(D(x)\\) near \\(1\\). For generated data \\(G(z)\\), it targets \\(D(G(z))\\) close to \\(0\\). Its objective is:\n\n\\[\n\\mathcal{L}(D) = \\log(D(x)) + \\log(1 - D(G(z))).\n\\]\n\nGenerator’s Objective: \\(G\\) aims for \\(D(G(z))\\) to approach \\(1\\), given by:\n\n\\[\n\\mathcal{L}(G) = \\log⁡(1 − D(G(z)))\n\\]\nBoth \\(G\\) and \\(D\\) continuously improve to outperform each other in this game.\n\nMinimax Game in GANs\nVanilla GANs are structured around the minimax game from game theory:\n\\[\n\\min_{G}\\max_{D} \\mathcal{L}(D, G) = \\log(D(x)) + \\log(1 - D(G(z)))\n\\]\nIn essence:\n\nDiscriminator: Maximizes its capacity to differentiate real data from generated.\nGenerator: Minimizes the discriminator’s success rate by producing superior forgeries.\n\nThe iterative competition refines both, targeting a proficient Generator and a perceptive Discriminator."
  },
  {
    "objectID": "posts/2023-10-10-vanilla-GANs/index.html#prepare-components",
    "href": "posts/2023-10-10-vanilla-GANs/index.html#prepare-components",
    "title": "Generative Adversarial Networks",
    "section": "Prepare Components",
    "text": "Prepare Components\nIn the upcoming sections, we’ll do the following steps to prepare the development environment:\n\nImport necessary libraries, primarily PyTorch and Matplotlib.\nDefine constants, including project path and seed, for consistency.\nDetermine the computational device (e.g., GPU).\nProvide a weight initialization helper function.\n\n\nfrom collections.abc import Callable, Sequence\nfrom pathlib import Path\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\n%config InlineBackend.figure_formats = {'retina', 'png'}\n\nimport torch\nfrom torch import Tensor, nn, optim\nfrom torch.utils.data import ConcatDataset, DataLoader, Dataset\nfrom torchinfo import summary\nfrom torchvision import transforms as T\nfrom torchvision.utils import make_grid\nfrom tqdm import tqdm\n\nSEED = 42\n\nPROJECT_PATH = Path(\".\").resolve()\nFIGURE_PATH = PROJECT_PATH / \"figures\"\nDATASET_PATH = Path.home() / \"datasets\"\n\n\nAMP_ENABLED = False\n\ndevice = torch.device(\"cpu\")\n\nif torch.cuda.is_available():\n    device = torch.device(\"cuda\")\n\n    if torch.cuda.is_bf16_supported():\n        AMP_ENABLED = True\n\n\ndef weights_init(net: nn.Module) -&gt; None:\n    for m in net.modules():\n        if isinstance(m, nn.Conv2d | nn.ConvTranspose2d):\n            nn.init.normal_(m.weight, 0.0, 0.02)\n            if m.bias is not None:\n                nn.init.constant_(m.bias, 0.0)\n\n        elif isinstance(m, nn.BatchNorm1d | nn.BatchNorm2d):\n            nn.init.normal_(m.weight, 1.0, 0.02)\n            if m.bias is not None:\n                nn.init.constant_(m.bias, 0.0)\n\n        elif isinstance(m, nn.Linear):\n            nn.init.normal_(m.weight, 0, 0.02)\n            if m.bias is not None:\n                nn.init.constant_(m.bias, 0.0)\n\n\nGenerator\nThe Generator in GANs acts as an artist, crafting data.\n\nInput: Takes random noise, typically from a standard normal distribution.\nArchitecture: Uses dense layers, progressively increasing data dimensions.\nOutput: Reshapes data to desired format (e.g., image). Often uses ‘tanh’ for activation.\nObjective: Generate data indistinguishable from real by the Discriminator.\n\n\nclass Generator(nn.Module):\n    def __init__(self, out_dim: Sequence[int], nz: int = 100, ngf: int = 256, alpha: float = 0.2):\n        \"\"\"\n        :param out_dim: output image dimension / shape\n        :param nz: size of the latent z vector $z$\n        :param ngf: size of feature maps (units in the hidden layers) in the generator\n        :param alpha: negative slope of leaky ReLU activation\n        \"\"\"\n        super().__init__()\n        self.out_dim = out_dim\n        self.model = nn.Sequential(\n            nn.Linear(nz, ngf),\n            nn.LeakyReLU(alpha, inplace=True),\n            nn.Linear(ngf, 2 * ngf),\n            nn.LeakyReLU(alpha, inplace=True),\n            nn.Linear(2 * ngf, 4 * ngf),\n            nn.LeakyReLU(alpha, inplace=True),\n            nn.Linear(4 * ngf, int(np.prod(self.out_dim))),\n            nn.Tanh(),\n        )\n\n    def forward(self, x: Tensor) -&gt; Tensor:\n        x = self.model(x)\n        x = torch.reshape(x, (x.size(0), *self.out_dim))\n        return x\n\n\nsummary(Generator(out_dim=(1, 28, 28)), input_size=[128, 100])\n\n==========================================================================================\nLayer (type:depth-idx)                   Output Shape              Param #\n==========================================================================================\nGenerator                                [128, 1, 28, 28]          --\n├─Sequential: 1-1                        [128, 784]                --\n│    └─Linear: 2-1                       [128, 256]                25,856\n│    └─LeakyReLU: 2-2                    [128, 256]                --\n│    └─Linear: 2-3                       [128, 512]                131,584\n│    └─LeakyReLU: 2-4                    [128, 512]                --\n│    └─Linear: 2-5                       [128, 1024]               525,312\n│    └─LeakyReLU: 2-6                    [128, 1024]               --\n│    └─Linear: 2-7                       [128, 784]                803,600\n│    └─Tanh: 2-8                         [128, 784]                --\n==========================================================================================\nTotal params: 1,486,352\nTrainable params: 1,486,352\nNon-trainable params: 0\nTotal mult-adds (Units.MEGABYTES): 190.25\n==========================================================================================\nInput size (MB): 0.05\nForward/backward pass size (MB): 2.64\nParams size (MB): 5.95\nEstimated Total Size (MB): 8.63\n==========================================================================================\n\n\n\n\nDiscriminator\nThe Discriminator is GAN’s evaluator, distinguishing real from fake data.\n\nInput: Takes either real data samples or those from the Generator.\nArchitecture: Employs dense layers for binary classification of the input.\nOutput: Uses a sigmoid activation, yielding a score between 0-1, reflecting the data’s authenticity.\nObjective: Recognize real data and identify fake data from the Generator.\n\n\nclass Discriminator(nn.Module):\n    def __init__(self, input_dim: Sequence[int], ndf: int = 128, alpha: float = 0.2):\n        super().__init__()\n        self.model = nn.Sequential(\n            nn.Linear(int(np.prod(input_dim)), 4 * ndf),\n            nn.LeakyReLU(alpha, inplace=True),\n            nn.Dropout(0.3),\n            nn.Linear(4 * ndf, 2 * ndf),\n            nn.LeakyReLU(alpha, inplace=True),\n            nn.Dropout(0.3),\n            nn.Linear(2 * ndf, ndf),\n            nn.LeakyReLU(alpha, inplace=True),\n            nn.Dropout(0.3),\n            nn.Linear(ndf, 1),\n            nn.Sigmoid(),\n        )\n\n    def forward(self, x: Tensor) -&gt; Tensor:\n        x = torch.reshape(x, (x.size(0), -1))\n        return self.model(x)\n\n\nsummary(Discriminator(input_dim=(1, 28, 28)), input_size=[128, 1, 28, 28])\n\n==========================================================================================\nLayer (type:depth-idx)                   Output Shape              Param #\n==========================================================================================\nDiscriminator                            [128, 1]                  --\n├─Sequential: 1-1                        [128, 1]                  --\n│    └─Linear: 2-1                       [128, 512]                401,920\n│    └─LeakyReLU: 2-2                    [128, 512]                --\n│    └─Dropout: 2-3                      [128, 512]                --\n│    └─Linear: 2-4                       [128, 256]                131,328\n│    └─LeakyReLU: 2-5                    [128, 256]                --\n│    └─Dropout: 2-6                      [128, 256]                --\n│    └─Linear: 2-7                       [128, 128]                32,896\n│    └─LeakyReLU: 2-8                    [128, 128]                --\n│    └─Dropout: 2-9                      [128, 128]                --\n│    └─Linear: 2-10                      [128, 1]                  129\n│    └─Sigmoid: 2-11                     [128, 1]                  --\n==========================================================================================\nTotal params: 566,273\nTrainable params: 566,273\nNon-trainable params: 0\nTotal mult-adds (Units.MEGABYTES): 72.48\n==========================================================================================\nInput size (MB): 0.40\nForward/backward pass size (MB): 0.92\nParams size (MB): 2.27\nEstimated Total Size (MB): 3.59\n=========================================================================================="
  },
  {
    "objectID": "posts/2023-10-10-vanilla-GANs/index.html#traning-loop",
    "href": "posts/2023-10-10-vanilla-GANs/index.html#traning-loop",
    "title": "Generative Adversarial Networks",
    "section": "Traning Loop",
    "text": "Traning Loop\nThe training process is iterative:\n\nUpdate Discriminator: With the Generator static, improve the Discriminator’s detection of real vs. fake.\nUpdate Generator: With a static Discriminator, enhance the Generator’s ability to deceive.\n\nTraining continues until the Generator produces almost authentic data. Equilibrium is reached when the Discriminator sees every input as equally likely real or fake, assigning a probability of \\(\\frac{1}{2}\\).\n\n\n\n\n\n\nNote\n\n\n\nUsing .eval() and .train() modes initially seemed promising for faster training. However, they affected layers like BatchNorm2d and Dropout, making the GAN diverge. Also, switching between eval and train modes is not free of charge.\n\n\n\ndef train_step(\n    generator: nn.Module,\n    discriminator: nn.Module,\n    optim_G: optim.Optimizer,\n    optim_D: optim.Optimizer,\n    criterion: Callable[[torch.Tensor, torch.Tensor], torch.Tensor],\n    real_data: torch.Tensor,\n    noise_dim: int,\n    device: torch.device,\n) -&gt; tuple[float, float]:\n    batch_size = real_data.size(0)\n\n    real_data = real_data.to(device)\n\n    # Labels for real and fake data\n    real_labels = torch.ones(batch_size, 1, device=device)\n    fake_labels = torch.zeros(batch_size, 1, device=device)\n\n    ### Train Discriminator\n\n    # Real data\n    output_real = discriminator(real_data)\n    loss_D_real = criterion(output_real, real_labels)\n\n    # Fake data\n    noise = torch.randn(batch_size, noise_dim, dtype=torch.float, device=device)\n    fake_data = generator(noise)\n    output_fake = discriminator(fake_data.detach())\n    loss_D_fake = criterion(output_fake, fake_labels)\n\n    # Backprop and optimize for discriminator\n    loss_D = (loss_D_real + loss_D_fake) / 2.0\n    discriminator.zero_grad()\n    loss_D.backward()\n    optim_D.step()\n\n    ### Train Generator\n\n    # Recompute fake data’s discriminator scores\n    output_fake = discriminator(fake_data)\n    loss_G = criterion(output_fake, real_labels)\n\n    # Backprop and optimize for generator\n    generator.zero_grad()\n    loss_G.backward()\n    optim_G.step()\n\n    return loss_G.item(), loss_D.item()"
  },
  {
    "objectID": "posts/2023-10-10-vanilla-GANs/index.html#evaluation",
    "href": "posts/2023-10-10-vanilla-GANs/index.html#evaluation",
    "title": "Generative Adversarial Networks",
    "section": "Evaluation",
    "text": "Evaluation\nBefore evaluation, we configured the learning rate (LR), optimizer’s \\(\\beta\\) parameters, batch size, and data loader settings for all experiments. We used the MNIST digits and MNIST fashion datasets for assessment.\n\nOPTIMIZER_LR = 0.0002\nL2_NORM = 1e-5\nOPTIMIZER_BETAS = (0.5, 0.999)\nN_EPOCHS = 100\nBATCH_SIZE = 128\n\n\ng = torch.Generator()\ng.manual_seed(SEED)\n\nloader_kwargs = {\n    \"num_workers\": 8,\n    \"pin_memory\": True,\n    \"shuffle\": True,\n    \"batch_size\": BATCH_SIZE,\n    \"prefetch_factor\": 16,\n    \"persistent_workers\": False,\n    \"worker_init_fn\": seed_worker,\n    \"generator\": g,\n}\n\n\nMNIST Digits Dataset\nThe MNIST (Modified National Institute of Standards and Technology) dataset is a well-known collection of handwritten digits, extensively used in the fields of machine learning and computer vision for training and testing purposes. Its simplicity and size make it a popular choice for introductory courses and experiments in image recognition.\nIn total, the dataset contains 70,000 grayscale images of handwritten digits (from 0 to 9). Each image is 28x28 pixels.\n\ndef get_minst_dataset(transform=None) -&gt; Dataset:\n    from torchvision.datasets import MNIST\n\n    root = str(DATASET_PATH)\n    trainset = MNIST(root=root, train=True, download=True, transform=transform)\n    testset = MNIST(root=root, train=False, download=True, transform=transform)\n    # Combine train and test dataset for more samples.\n    dataset = ConcatDataset([trainset, testset])\n    return dataset\n\n\nIMG_DIM = (1, 28, 28)\nNOISE_DIM = 100\n\n\ntransform = T.Compose(\n    [\n        T.ToTensor(),\n        T.Normalize(0.5, 0.5),\n    ]\n)\n\ndata = get_minst_dataset(transform=transform)\ndataloader = DataLoader(data, **loader_kwargs)\n\n# set seed for random generators\nset_random_seed()\n\n# benchmark_noise is used for the animation to show how output evolve on the same vector\nbenchmark_noise = torch.randn(16 * 16, NOISE_DIM, device=device)\n\ngenerator = Generator(out_dim=IMG_DIM, nz=NOISE_DIM).to(device)\ngenerator.apply(weights_init)\n\ndiscriminator = Discriminator(input_dim=IMG_DIM).to(device)\ndiscriminator.apply(weights_init)\n\noptimizer_G = optim.AdamW(\n    generator.parameters(),\n    lr=OPTIMIZER_LR,\n    betas=OPTIMIZER_BETAS,\n    weight_decay=L2_NORM,\n)\n\noptimizer_D = optim.AdamW(\n    discriminator.parameters(),\n    lr=OPTIMIZER_LR,\n    betas=OPTIMIZER_BETAS,\n    weight_decay=L2_NORM,\n)\n\ncriterion = nn.BCELoss().to(device)\n\n\nanimation: list[Tensor] = []\n\ng_losses: list[float] = []\nd_losses: list[float] = []\n\nfor _ in tqdm(range(N_EPOCHS), unit=\"epochs\"):\n    generator.train()\n    discriminator.train()\n\n    for samples_real, _ in dataloader:\n        g_loss, d_loss = train_step(\n            generator, discriminator, optimizer_G, optimizer_D, criterion, samples_real, NOISE_DIM, device\n        )\n\n        g_losses.append(g_loss)\n        d_losses.append(d_loss)\n\n    generator.eval()\n    with torch.inference_mode():\n        images = generator(benchmark_noise)\n        images = images.detach().cpu()\n\n        images = make_grid(images, nrow=16, normalize=True)\n        animation.append(images)\n\n100%|██████████| 100/100 [07:44&lt;00:00,  4.64s/epochs]\n\n\n\n\n\n\n\nGenerator and Discriminator loss evolution over epochs using Vanilla GAN on the MNIST digit dataset.\n\n\n\n\n\n\n\nMNIST Fashion Dataset\nThe Fashion MNIST dataset is a collection of grayscale images of 10 different categories of clothing items, designed as a more challenging alternative to the classic MNIST dataset of handwritten digits. Each image in the dataset is 28x28 pixels. The 10 categories include items like t-shirts/tops, trousers, pullovers, dresses, coats, sandals, and more. With 70,000 images, Fashion MNIST is commonly used for benchmarking machine learning algorithms, especially in image classification tasks.\n\nIMG_DIM = (1, 28, 28)\nNOISE_DIM = 100\n\n\ndef get_mnist_fashion_dataset(transform=None):\n    from torchvision.datasets import FashionMNIST\n\n    root = str(DATASET_PATH)\n    trainset = FashionMNIST(root=root, train=True, download=True, transform=transform)\n    testset = FashionMNIST(root=root, train=False, download=True, transform=transform)\n    # Combine train and test dataset for more samples.\n    dataset = ConcatDataset([trainset, testset])\n    return dataset\n\n\ntransform = T.Compose([T.ToTensor(), T.Normalize(0.5, 0.5)])\n\ndata = get_mnist_fashion_dataset(transform=transform)\ndataloader = DataLoader(data, **loader_kwargs)\n\n# set seed for random generators\nset_random_seed()\n\n# benchmark_noise is used for the animation to show how output evolve on same vector\nbenchmark_noise = torch.randn(16 * 16, NOISE_DIM, device=device)\n\ngenerator = Generator(out_dim=IMG_DIM, nz=NOISE_DIM).to(device)\ngenerator.apply(weights_init)\n\ndiscriminator = Discriminator(input_dim=IMG_DIM).to(device)\ndiscriminator.apply(weights_init)\n\noptimizer_G = optim.AdamW(\n    generator.parameters(),\n    lr=OPTIMIZER_LR,\n    betas=OPTIMIZER_BETAS,\n    weight_decay=L2_NORM,\n)\n\noptimizer_D = optim.AdamW(\n    discriminator.parameters(),\n    lr=OPTIMIZER_LR,\n    betas=OPTIMIZER_BETAS,\n    weight_decay=L2_NORM,\n)\n\ncriterion = nn.BCELoss().to(device)\n\n\nanimation = []\n\ng_losses, d_losses = [], []\nfor _ in tqdm(range(N_EPOCHS), unit=\"epochs\"):\n    generator.train()\n    discriminator.train()\n\n    for samples_real, _ in dataloader:\n        g_loss, d_loss = train_step(\n            generator, discriminator, optimizer_G, optimizer_D, criterion, samples_real, NOISE_DIM, device\n        )\n\n        g_losses.append(g_loss)\n        d_losses.append(d_loss)\n\n    generator.eval()\n    with torch.inference_mode():\n        images = generator(benchmark_noise)\n        images = images.detach().cpu()\n\n        images = make_grid(images, nrow=16, normalize=True)\n\n        animation.append(images)\n\n100%|██████████| 100/100 [07:46&lt;00:00,  4.67s/epochs]\n\n\n\n\n\n\n\nGenerator and Discriminator loss evolution over epochs using Vanilla GAN on the MNIST fashion dataset."
  },
  {
    "objectID": "posts/2023-10-10-vanilla-GANs/index.html#setting-up-dcgans",
    "href": "posts/2023-10-10-vanilla-GANs/index.html#setting-up-dcgans",
    "title": "Generative Adversarial Networks",
    "section": "Setting Up DCGANs",
    "text": "Setting Up DCGANs\n\nGenerator\n\nclass Generator(nn.Module):\n    def __init__(self, nz: int = 100, ngf: int = 32, nc: int = 1):\n        \"\"\"\n        :param nz: size of the latent z vector\n        :param ngf: size of feature maps in generator\n        :param nc: number of channels in the training images.\n        \"\"\"\n        super().__init__()\n        self.layers = nn.Sequential(\n            nn.ConvTranspose2d(nz, 4 * ngf, 4, 1, 0, bias=False),\n            nn.BatchNorm2d(4 * ngf),\n            nn.ReLU(inplace=True),\n            nn.ConvTranspose2d(4 * ngf, 2 * ngf, 3, 2, 1, bias=False),\n            nn.BatchNorm2d(2 * ngf),\n            nn.ReLU(inplace=True),\n            nn.ConvTranspose2d(2 * ngf, ngf, 4, 2, 1, bias=False),\n            nn.BatchNorm2d(ngf),\n            nn.ReLU(inplace=True),\n            nn.ConvTranspose2d(ngf, nc, 4, 2, 1, bias=False),\n            nn.Tanh(),\n        )\n\n    def forward(self, x: Tensor) -&gt; Tensor:\n        x = torch.reshape(x, (x.size(0), -1, 1, 1))\n        return self.layers(x)\n\n\nsummary(Generator(), input_size=(128, 100))\n\n==========================================================================================\nLayer (type:depth-idx)                   Output Shape              Param #\n==========================================================================================\nGenerator                                [128, 1, 28, 28]          --\n├─Sequential: 1-1                        [128, 1, 28, 28]          --\n│    └─ConvTranspose2d: 2-1              [128, 128, 4, 4]          204,800\n│    └─BatchNorm2d: 2-2                  [128, 128, 4, 4]          256\n│    └─ReLU: 2-3                         [128, 128, 4, 4]          --\n│    └─ConvTranspose2d: 2-4              [128, 64, 7, 7]           73,728\n│    └─BatchNorm2d: 2-5                  [128, 64, 7, 7]           128\n│    └─ReLU: 2-6                         [128, 64, 7, 7]           --\n│    └─ConvTranspose2d: 2-7              [128, 32, 14, 14]         32,768\n│    └─BatchNorm2d: 2-8                  [128, 32, 14, 14]         64\n│    └─ReLU: 2-9                         [128, 32, 14, 14]         --\n│    └─ConvTranspose2d: 2-10             [128, 1, 28, 28]          512\n│    └─Tanh: 2-11                        [128, 1, 28, 28]          --\n==========================================================================================\nTotal params: 312,256\nTrainable params: 312,256\nNon-trainable params: 0\nTotal mult-adds (Units.GIGABYTES): 1.76\n==========================================================================================\nInput size (MB): 0.05\nForward/backward pass size (MB): 24.26\nParams size (MB): 1.25\nEstimated Total Size (MB): 25.57\n==========================================================================================\n\n\n\n\nDiscriminator\n\nclass Discriminator(nn.Module):\n    def __init__(self, ndf: int = 32, nc: int = 1, alpha: float = 0.2):\n        super().__init__()\n        self.layers = nn.Sequential(\n            nn.Conv2d(nc, ndf, 4, 2, 1, bias=False),\n            nn.BatchNorm2d(ndf),\n            nn.LeakyReLU(alpha, inplace=True),\n            nn.Conv2d(ndf, 2 * ndf, 4, 2, 1, bias=False),\n            nn.BatchNorm2d(2 * ndf),\n            nn.LeakyReLU(alpha, inplace=True),\n            nn.Conv2d(2 * ndf, 4 * ndf, 3, 2, 1, bias=False),\n            nn.BatchNorm2d(ndf * 4),\n            nn.LeakyReLU(alpha, inplace=True),\n            nn.Conv2d(4 * ndf, 1, 4, 1, 0, bias=False),\n            nn.Sigmoid(),\n        )\n\n    def forward(self, x: Tensor) -&gt; Tensor:\n        x = self.layers(x)\n        x = torch.reshape(x, (x.size(0), -1))\n        return x\n\n\nsummary(Discriminator(), input_size=(BATCH_SIZE, 1, 28, 28))\n\n==========================================================================================\nLayer (type:depth-idx)                   Output Shape              Param #\n==========================================================================================\nDiscriminator                            [128, 1]                  --\n├─Sequential: 1-1                        [128, 1, 1, 1]            --\n│    └─Conv2d: 2-1                       [128, 32, 14, 14]         512\n│    └─BatchNorm2d: 2-2                  [128, 32, 14, 14]         64\n│    └─LeakyReLU: 2-3                    [128, 32, 14, 14]         --\n│    └─Conv2d: 2-4                       [128, 64, 7, 7]           32,768\n│    └─BatchNorm2d: 2-5                  [128, 64, 7, 7]           128\n│    └─LeakyReLU: 2-6                    [128, 64, 7, 7]           --\n│    └─Conv2d: 2-7                       [128, 128, 4, 4]          73,728\n│    └─BatchNorm2d: 2-8                  [128, 128, 4, 4]          256\n│    └─LeakyReLU: 2-9                    [128, 128, 4, 4]          --\n│    └─Conv2d: 2-10                      [128, 1, 1, 1]            2,048\n│    └─Sigmoid: 2-11                     [128, 1, 1, 1]            --\n==========================================================================================\nTotal params: 109,504\nTrainable params: 109,504\nNon-trainable params: 0\nTotal mult-adds (Units.MEGABYTES): 369.68\n==========================================================================================\nInput size (MB): 0.40\nForward/backward pass size (MB): 23.46\nParams size (MB): 0.44\nEstimated Total Size (MB): 24.30\n=========================================================================================="
  },
  {
    "objectID": "posts/2023-10-10-vanilla-GANs/index.html#evaluation-1",
    "href": "posts/2023-10-10-vanilla-GANs/index.html#evaluation-1",
    "title": "Generative Adversarial Networks",
    "section": "Evaluation",
    "text": "Evaluation\n\nMNIST Digits Dataset\n\nIMG_DIM = (1, 28, 28)\nNOISE_DIM = 128\n\ntransform = T.Compose(\n    [\n        T.ToTensor(),\n        T.Normalize(0.5, 0.5),\n    ]\n)\n\ndata = get_minst_dataset(transform)\ndataloader = DataLoader(data, **loader_kwargs)\n\n# set seed for random generators\nset_random_seed()\n\n# benchmark_noise is used for the animation to show how output evolve on same vector\nbenchmark_noise = torch.randn(16 * 16, NOISE_DIM, device=device)\n\ngenerator = Generator(nz=NOISE_DIM, ngf=32, nc=IMG_DIM[0]).to(device)\ngenerator.apply(weights_init)\n\ndiscriminator = Discriminator(ndf=32, nc=IMG_DIM[0]).to(device)\ndiscriminator.apply(weights_init)\n\noptimizer_G = optim.AdamW(\n    generator.parameters(),\n    lr=OPTIMIZER_LR,\n    betas=OPTIMIZER_BETAS,\n    weight_decay=L2_NORM,\n)\n\noptimizer_D = optim.AdamW(\n    discriminator.parameters(),\n    lr=OPTIMIZER_LR,\n    betas=OPTIMIZER_BETAS,\n    weight_decay=L2_NORM,\n)\n\ncriterion = nn.BCELoss().to(device)\n\n\nanimation = []\n\ng_losses, d_losses = [], []\nfor _ in tqdm(range(N_EPOCHS), unit=\"epochs\"):\n    generator.train()\n    discriminator.train()\n\n    for samples_real, _ in dataloader:\n        g_loss, d_loss = train_step(\n            generator, discriminator, optimizer_G, optimizer_D, criterion, samples_real, NOISE_DIM, device\n        )\n\n        g_losses.append(g_loss)\n        d_losses.append(d_loss)\n\n    generator.eval()\n    with torch.inference_mode():\n        images = generator(benchmark_noise)\n        images = images.detach().cpu()\n\n        images = make_grid(images, nrow=16, normalize=True)\n\n        animation.append(images)\n\n100%|██████████| 100/100 [05:22&lt;00:00,  3.22s/epochs]\n\n\n\n\n\n\n\nGenerator and Discriminator loss evolution over epochs using DCGAN on the MNIST digit dataset.\n\n\n\n\n\n\n\nMNIST Fashion Dataset\n\nIMG_DIM = (1, 28, 28)\nNOISE_DIM = 128\n\ntransform = T.Compose(\n    [\n        T.ToTensor(),\n        T.Normalize(0.5, 0.5),\n    ]\n)\n\ndata = get_mnist_fashion_dataset(transform)\ndataloader = DataLoader(data, **loader_kwargs)\n\n# set seed for random generators\nset_random_seed()\n\n# benchmark_noise is used for the animation to show how output evolve on same vector\nbenchmark_noise = torch.randn(16 * 16, NOISE_DIM, device=device)\n\ngenerator = Generator(nz=NOISE_DIM, ngf=32, nc=IMG_DIM[0]).to(device)\ngenerator.apply(weights_init)\n\ndiscriminator = Discriminator(ndf=32, nc=IMG_DIM[0]).to(device)\ndiscriminator.apply(weights_init)\n\noptimizer_G = optim.AdamW(\n    generator.parameters(),\n    lr=OPTIMIZER_LR,\n    betas=OPTIMIZER_BETAS,\n    weight_decay=L2_NORM,\n)\n\noptimizer_D = optim.AdamW(discriminator.parameters(), lr=OPTIMIZER_LR, betas=OPTIMIZER_BETAS, weight_decay=L2_NORM)\n\ncriterion = nn.BCELoss().to(device)  # F.binary_cross_entropy_with_logits #nn.BCELoss().to(device)\n\n\nanimation = []\n\ng_losses, d_losses = [], []\nfor _ in tqdm(range(N_EPOCHS), unit=\"epochs\"):\n    generator.train()\n    discriminator.train()\n\n    for samples_real, _ in dataloader:\n        g_loss, d_loss = train_step(\n            generator, discriminator, optimizer_G, optimizer_D, criterion, samples_real, NOISE_DIM, device\n        )\n\n        g_losses.append(g_loss)\n        d_losses.append(d_loss)\n\n    generator.eval()\n    with torch.inference_mode():\n        images = generator(benchmark_noise)\n        images = images.detach().cpu()\n\n        images = make_grid(images, nrow=16, normalize=True)\n\n        animation.append(images)\n\n100%|██████████| 100/100 [05:24&lt;00:00,  3.24s/epochs]\n\n\n\n\n\n\n\nGenerator and Discriminator loss evolution over epochs using DCGAN on the MNIST fashion dataset."
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html",
    "href": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html",
    "title": "Bernoulli Multi-Armed Bandit Problem",
    "section": "",
    "text": "Note\n\n\n\nCredits to Lil’s blog post. I slightly improved and extended it for myself to better understand statistical terms.\nThe exploitation-exploration dilemma exists in many aspects of our lives. For instance, for your favourite option (e.g., restaurant, chatbot, artist, busic band) you are confident of what you will get, but you miss the chance to discover an even better option. But if you choose to try new options all the time, you’re very likely gonna deal with unpleasant service from time to time. Not every new option pays off.\nThis trade-off becomes especially important when we operate under incomplete information. Without full knowledge of our environment, we must gather information while simultaneously making good decisions. Exploitation uses what what we’ve learned, while exploration risks short-term loss to gain long-term insight.\nTo see how this plays out in a clean mathematical settings, we turn to a classic model."
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html#formal-definition",
    "href": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html#formal-definition",
    "title": "Bernoulli Multi-Armed Bandit Problem",
    "section": "Formal Definition",
    "text": "Formal Definition\nWith the intuition in place, we can now describe the Bernoulli multi-armed bandit more formally. A bandit problem is defined as a tuple \\(\\langle \\mathcal{A}, \\mathcal{R} \\rangle\\), where:\n\nWe have \\(K\\) machines (or levers) with probabilities \\(\\{ \\theta_{1}, \\ldots, \\theta_{K} \\}\\).\nAt each time step \\(t\\), we take an action \\(a_t\\) on one slot machine and receive a reward \\(r_t\\).\n\\(\\mathcal{A}\\) is a set of possible actions. The value of an action is expected reward, \\(Q(a) = \\mathbb{E}[r|a] = \\theta\\). If action \\(a_{t}\\) corresponds to machine \\(i\\), then \\(Q(a_{t}) = \\theta_{i}\\).\n\\(\\mathcal{R}\\) is the reward function. In a Bernoulli bandit, each pull yields a reward of \\(1\\) with probability \\(Q(a_{t})\\), and \\(0\\) otherwise.\n\n\n\n\n\n\n\nNote\n\n\n\nRecall that a Bernoulli distribution is a discrete probability distribution, which takes the value \\(1\\) with probability \\(p\\) and \\(0\\) with probability \\(1 - p\\).\nThe symbol \\(\\mathbb{E}[\\cdot]\\) denotes the expected value, a generalized weighted average. The expression \\(\\mathbb{E}[r|a]\\) reads as the expected reward (\\(r\\)) that we took action \\(a\\).”\nCrucially, the probabilities \\(\\{\\theta_{i}\\}\\) are NOT known in advance. They must be estimated through interaction.\n\n\nA Bernoulli bandit can be seen as a simplified Marko decision process (MDP) without a state space. The objective is to maximize the total reward \\(\\sum_{t=1}^{T} r_{t}\\). If we knew which action had the biggest reward probability, this would be equivalent to minimizing the regret from not always choosing that optimal action.\nLet \\(\\theta^{*}\\) denote the reward probability of the optimal action \\(a^{*}\\):\n\\[\n\\theta^{*} = Q(a^{*}) = \\max_{a \\in \\mathcal{A}} Q(a) = \\max_{1 \\leq i \\leq K} \\theta_{i}\n\\]\nThe expected cumulative regret up to the time \\(T\\) is then:\n\\[\n\\mathcal{L}_{T} = \\mathbb{E}\\left[\\sum_{t=1}^{T}(\\theta^{*} - Q(a_{t}))\\right]\n\\]\n\nclass BernoulliBandit(BaseBandit):\n    def __init__(\n        self,\n        k: int,\n        probas: list[float] | npt.NDArray[np.float64] | None = None,\n        seed: int | None = None,\n    ):\n        # sanity check: `probas` needs to be None or of size `n`.\n        assert probas is None or len(probas) == k\n\n        self.k = k  # save number of bandits\n\n        self.rng = np.random.default_rng(seed=seed)\n\n        # random probabilities, if they are explicitly defined\n        if probas is None:\n            probas = self.rng.random(size=self.k)\n\n        # convert to numpy array for easier operations later\n        self.probas = np.asarray(probas)\n\n        # in case of Bernoulli MAB, highest probabily is equal to optimal\n        self.best_proba = np.max(self.probas)\n\n    def generate_reward(self, i: int) -&gt; int:\n        # The player selected the i-th machine.\n        return int(self.rng.random() &lt; self.probas[i])"
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html#bandit-strategies",
    "href": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html#bandit-strategies",
    "title": "Bernoulli Multi-Armed Bandit Problem",
    "section": "Bandit Strategies",
    "text": "Bandit Strategies\nWith the bandint problem formally defined, the next question is: how should we choose actions over time? Different strategies encode different assumptions about how exploration should be handled. Broadly, we can distinguish three categories:\n\nNo exploration: always exploit the best-known action (naive and generally poor).\nRandom exploration: explore uniformly at random.\nInformed exploration: explore more often when uncertainty is high.\n\nA simple and widely used example of the last category is the \\(\\epsilon\\)-greedy algorithm."
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html#unified-definition",
    "href": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html#unified-definition",
    "title": "Bernoulli Multi-Armed Bandit Problem",
    "section": "Unified Definition",
    "text": "Unified Definition\n\nInformation State\nAt time step \\(t\\), the UCB algorithms maintains:\n\nempirical action-value estimates \\(\\hat{Q}_t(a)\\),\naction counts \\(N_t(a)\\).\n\nThe quantities summarize the full interaction history.\n\n\nPolicy\nUCB defines deterministic policy:\n\\[\n\\pi(a|h_t) = \\begin{cases}\n    1, & a = \\arg\\max_{a'} \\left[ \\hat{Q}_t(a') + \\hat{U}_t(a') \\right], \\\\\n    0, & \\text{otherwise}.\n\\end{cases}\n\\]\nUnlike \\(\\epsilon\\)-greedy, exploration is not injected explicitly. Instead, it emerges through optimism in the face of uncertainty.\n\n\nAction Selection\nAt each time step, the selected action is:\n\\[\na_t = \\arg\\max_{a \\in \\mathcal{A}} \\left[ \\hat{Q}_t(a) + \\hat{U}_t(a) \\right].\n\\]\n\n\nUpdate Rule\nAfter selecting action \\(a_t\\) and observing reward \\(r_t\\), the algorithm updates:\n\nthe action counts \\(N_t(a_t)\\)\nthe empirical estimate \\(\\hat{Q}_t(a_t)\\)\n\n\n\nChoosing the Uncertainty Bound\nThe remaining design choice is how to define \\(\\hat{U}_t(a)\\). Different choices lead to different members of the UCB family, such as UCB1, which derives its bound from Hoeffding’s inequality.\nNow the question is: how do we choose the uncertainty bound \\(\\hat{U}_t(a)\\)?"
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html#hoeffdings-inequality",
    "href": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html#hoeffdings-inequality",
    "title": "Bernoulli Multi-Armed Bandit Problem",
    "section": "Hoeffding’s Inequality",
    "text": "Hoeffding’s Inequality\nIf we do not want to assign any prior knowledge about the shape of the reward distribution (e.g., Gaussian, exponential), we can rely on Hoeffding’s Inequality. This theorem is applicable on any bounded distribution.\nA random variable is said to follow a bounded distribution if all its values lie within a fixed finite interval \\([a,b]\\). In our case, Bernoulli rewards always lie in \\([0,1]\\), so the boundedness assumption is naturally satisfied.\n\n\n\n\n\n\nNote\n\n\n\nHere are a few examples for intuition:\n\nA Bernoulli distribution is bounded on interval \\([0,1]\\).\nA uniform distribution on interval e.g., \\([2,5]\\) is bounded.\nA Gaussian distribution is not bounded because of its infinite tails.\n\n\n\n\nHoeffding’s Inequality (informal version)\nLet \\(X_1, \\ldots, X_t\\) be i.i.d. (independent and identically distributed) random variables, all bounded in the interval \\([0,1]\\). The sample mean is\n\\[\n\\overline{X}_t = \\frac{1}{t} \\sum_{\\tau = 1}^{t} X_{\\tau}.\n\\]\nThen for any \\(u \\gt 0\\), Hoeffding’s inequality states:\n\\[\n\\mathbb{P}\\left[\\mathbb{E}[X] \\gt \\overline{X}_{t} + u \\right] \\leq \\mathrm{e}^{-2tu^2}.\n\\]\nThis inequality bounds the probability that the true mean exceeds the empirical mean my more than \\(u\\).\n\n\nApplying Hoeffding’s Inequality to Bandit Rewards\nTo apply this result to the multi-armed bandit setting, we observe that each fixed action \\(a\\) defines its own random reward-generating process. Every time we select action \\(a\\), we obtain a reward drawn independently from the same bounded distribution. Therefore, Hoeffding’s inequality applies directly to each arm.\nFor a fixed target action \\(a\\), define:\n\n\\(r_{\\tau}(a)\\) as the reward random variable,\n\\(Q(a)\\) as the true mean reward,\n\\(\\hat{Q}_{t}(a)\\) as the sample mean reward,\nand \\(u = U_{t}(a)\\) as the upper confidence bound.\n\nBy directly identifying Hoeffding’s variables with the bandit quantities:\n\\[\nX_{\\tau} \\leftrightarrow r_\\tau(a),\\quad\n\\mathbb{E}[X] \\leftrightarrow Q(a),\\quad\n\\overline{X} \\leftrightarrow \\hat{Q}_{t}(a),\\quad\nt \\leftrightarrow N_{t}(a)\n\\]\nwe obtain:\n\\[\n\\mathbb{P} \\left[ Q(a) \\gt \\hat{Q}_{t}(a) + U_{t}(a) \\right] \\leq \\mathrm{e}^{-2 N_{t}(a) U_{t}(a)^2}.\n\\]\nThis gives a probabilistic upper bound on how much the true reward of an action can exceed its empirical estimate.\n\n\nChoosing the Upper Confidence Bound\nWe want to select the confidence bound so that the probability of underestimating the true mean is very small. Let us require this probability to be below a small threshold \\(p\\):\n\\[\n\\mathrm{e}^{-2N_{t}(a)U_{t}(a)^2} = p.\n\\]\nSolving for \\(U_{t}(a)\\), we obtain:\n\\[\nU_{t}(a) = \\sqrt{\\frac{-\\ln{p}}{2N_{t}(a)}}.\n\\]\nThis expression defines how much optimism we should add to the empirical estimate based on how many times the action has been sampled."
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html#ucb1",
    "href": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html#ucb1",
    "title": "Bernoulli Multi-Armed Bandit Problem",
    "section": "UCB1",
    "text": "UCB1\nFrom the previous section, we obtained a general form of the confidence bound:\n\\[\nU_{t}(a) = \\sqrt{\\frac{-\\ln{p}}{2N_{t}(a)}}.\n\\]\nThe remaining question is how to choose the threshold probability \\(p\\). Intuitively, as time goes on and we collect more data, we want our confidence bounds to become tighter and failures to become increasingly unlikely. A simple and effective heuristic is to let the failure probability decrease with time.\nA common choice is:\n\\[\np = t^{-4},\n\\]\nwhich makes the failure probabilities summable over time and enables strong regret guarantees.\nSubstituting this into the confidence bound gives:\n\\[\nU_{t}(a) = \\sqrt{\\frac{2\\ln{t}}{N_{t}(a)}}.\n\\]\nThis yields the classic UCB1 algorithm.\nAt each time step, UCB1 selects the action that maximizes the optimistic estimate of the reward:\n\\[\na_{t}^\\textrm{UCB1} = \\arg\\max_{a \\in \\mathcal{A}} \\left[ \\hat{Q}_t(a) + \\sqrt{\\frac{2\\ln{t}}{N_{t}(a)}} \\right].\n\\]\nHere:\n\n\\(\\hat{Q}_{t}(a)\\) promotes exploitation,\nthe square-root term promotes exploration, shrinking as \\(N_{t}(a)\\) increases,\nand the \\(\\ln{t}\\) term ensures that even rarely chosen actions are revisited occasionally.\n\n\n\n\n\n\n\nNote\n\n\n\nWhy this works (one sentence intuition)\nUCB1 always chooses the action with the highest plausible reward, where “plausible” is defined by a confidence interval that shrinks as evidence accumulates.\n\n\n\nclass UCB1(BaseSolver):\n    def __init__(self, bandit: BaseBandit, init_proba: float = 1.0, seed: int | None = None):\n        super().__init__(bandit)\n        self.t = 0  # number of time steps\n        self.estimates = np.full(shape=self.bandit.k, fill_value=init_proba, dtype=np.float64)\n        self.rng = np.random.default_rng(seed)\n\n    @property\n    def estimated_probas(self) -&gt; npt.NDArray[np.float64]:\n        return self.estimates\n\n    def run_one_step(self) -&gt; tuple[int, float]:\n        self.t += 1\n\n        # Pick the best one with consideration of upper confidence bounds.\n        ucb = self.estimates + np.sqrt(2 * np.log(self.t) / (1 + self.counts))\n\n        # tie-breaking\n        candidates = np.flatnonzero(ucb == ucb.max())\n        i = int(self.rng.choice(candidates))\n\n        r = self.bandit.generate_reward(i)\n\n        self.estimates[i] += 1.0 / (self.counts[i] + 1) * (r - self.estimates[i])\n\n        return i, r"
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html#using-distributional-assumptions",
    "href": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html#using-distributional-assumptions",
    "title": "Bernoulli Multi-Armed Bandit Problem",
    "section": "Using Distributional Assumptions",
    "text": "Using Distributional Assumptions\nFor example, suppose we believe that the mean reward of each slot machine follows a Gaussian likelihood, which induces a Gaussian posterior distribution over the mean reward of each action. After observing rewards for a given action \\(a\\), the posterior is characterized by:\n\na posterior mean \\(\\mu_{t}(a)\\),\nand a posterior standard deviation \\(\\sigma_{t}(a)\\)\n\nIn this case, a natural choice for the upper confidence bound is the upper quantile of the posterior, for instance a 95% confidence bound:\n\\[\n\\hat{U}_{t}(a) = c\\sigma_{t}(a),\n\\]\nwhere \\(c \\approx 2\\) corresponds to a 95% credible interval for a Gaussian distribution.\nThe Bayesian UCB action selection rule then becomes:\n\\[\na_{t}^{Bayes\\text{-}UCB} = \\arg\\max_{a \\in \\mathcal{A}}\\left[ \\mu_{t}(a) + c \\sigma_{t}(a) \\right].\n\\]\nInterpretation:\n\n\\(\\mu_{t}(a)\\) plays the role of exploitation (current best estimate),\n\\(\\sigma_{t}(a)\\) captures uncertainty (how much we still do not know),\nthe constant \\(c\\) controls how optimistic we are.\n\nCompared to UCB1, where uncertainty depends only on \\(N_{t}(a)\\), Bayesian UCB uses the full posterior uncertainty, which often leads to faster learning when the model assumptions are correct."
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html#key-difference-from-ucb1",
    "href": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html#key-difference-from-ucb1",
    "title": "Bernoulli Multi-Armed Bandit Problem",
    "section": "Key Difference from UCB1",
    "text": "Key Difference from UCB1\n\n\n\nUCB1\nBayesian UCB\n\n\n\n\nNo distributional assumption\nExplicit reward model\n\n\nHoeffding bound\nPosterior quantile\n\n\nWorst-case guarantees\nModel dependent efficiency\n\n\n\n\nclass BayesianUCB(BaseSolver):\n    def __init__(\n        self, bandit: BaseBandit, c: float = 2, init_a: float = 1, init_b: float = 1, seed: int | None = None\n    ) -&gt; None:\n        super().__init__(bandit)\n\n        self.c = c\n        self._as = np.full(self.bandit.k, fill_value=init_a, dtype=np.float64)\n        self._bs = np.full(self.bandit.k, fill_value=init_b, dtype=np.float64)\n\n        self.t = 0\n        self.rng = np.random.default_rng(seed)\n\n    @property\n    def estimated_probas(self) -&gt; npt.NDArray[np.float64]:\n        return self._as / (self._as + self._bs)\n\n    def run_one_step(self) -&gt; tuple[int, float]:\n        from scipy.stats import beta\n\n        self.t += 1\n\n        # ensure each arm is tried at least once\n        if self.t &lt;= self.bandit.k:\n            i = self.t - 1\n        else:\n            mu = self._as / (self._as + self._bs)  # posterior mean\n            sigma = beta.std(self._as, self._bs)  # posterior std Beta(alpha, beta)\n            confidence = mu + self.c * sigma\n\n            # tie-breaking\n            candidates = np.flatnonzero(confidence == confidence.max())\n            i = self.rng.choice(candidates)\n\n        r = self.bandit.generate_reward(i)\n\n        # update Beta posterior for Bernoulli reward\n        self._as[i] += r  # successes\n        self._bs[i] += 1 - r  # failures\n\n        return i, r"
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html#thompson-sampling-for-bernoulli-bandits-beta-bernoulli",
    "href": "posts/reinforcement-learning/2025-12-16-multi-armed-bandit-problem.html#thompson-sampling-for-bernoulli-bandits-beta-bernoulli",
    "title": "Bernoulli Multi-Armed Bandit Problem",
    "section": "Thompson Sampling for Bernoulli Bandits (Beta-Bernoulli)",
    "text": "Thompson Sampling for Bernoulli Bandits (Beta-Bernoulli)\nIn the Bernoulli banding setting, the reward of each action is either \\(0\\) or \\(1\\). The conjugate prior for the Bernoulli distribution is the Beta distribution, so we model each action as:\n\\[\n\\theta_{a} \\sim \\textrm{Beta}(\\alpha_a, \\beta_a),\n\\]\nwhere:\n\n\\(\\alpha_a\\) counts observed successes,\n\\(\\beta_a\\) counts observed failures.\n\nInitially, we typically use a non-informative prior such as:\n\\[\n\\alpha_a = 1, \\quad \\beta_a = 1.\n\\]\n\nAction Selection\nAt time \\(t\\) Thompson Sampling performs:\n\\[\n\\tilde{\\theta_a} \\sim \\textrm{Beta}(\\alpha_a, \\beta_a) \\quad \\textrm{for each} a \\in \\mathcal{A},\n\\]\nand selects:\n\\[\na_t^\\textrm{TS} = \\arg\\max_{a \\in \\mathcal{A}} \\tilde{\\theta}_a.\n\\]\nThat is, we draw one plausible value for each arm and act greedly with respect to this randomly sampled world.\n\n\nPosterior Update\nAfter observing the reward \\(r_t \\in {0,1}\\), we update:\n\\[\n\\alpha_a \\leftarrow \\alpha_a + r_t, \\quad \\beta_a \\leftarrow \\beta_a + (1 - r_t).\n\\]\nThis update is exact Bayesian inference for the Bernoulli-Beta model.\n\n\nWhy Thompson Sampling Works so Well\nThompson Sampling does not separate exploration from exploitation. Instead, exploration emerges naturally from uncertainty in the posterior:\n\nIf an action is well understood, its posterior is sharp (little randomness).\nIf an action is uncertain, its posterior is wide (occasional optimistic samples).\n\nIn contrast:\n\n\\(\\epsilon\\)-greedy explores blindly,\nUCB explores via deterministic optimism,\nThompson Sampling explores via probabilistic belief.\n\n\n\nRelationship to Bayesian UCB\nBayesian UCB selects actions using:\n\\[\n\\mu_t(a) + c \\sigma_t(a),\n\\]\nwhich corresponds to choosing a fixed upper quantile of the posterior.\nThompson Sampling instead draws a random quantile at every time step. In this sense:\n\nBayesian UCB is optimistic; Thompson Sampling is probabilistic.\n\nBoth use Bayesian posteriors, but Thompson Sampling avoids manually choosing confidence levels.\n\nclass ThompsonSampling(BaseSolver):\n    def __init__(self, bandit: BaseBandit, init_a: int = 1, init_b: int = 1, seed: int | None = None) -&gt; None:\n        super().__init__(bandit)\n\n        self._as = np.full(self.bandit.k, fill_value=init_a, dtype=np.float64)\n        self._bs = np.full(self.bandit.k, fill_value=init_b, dtype=np.float64)\n\n        self.rng = np.random.default_rng(seed)\n\n    @property\n    def estimated_probas(self) -&gt; npt.NDArray[np.float64]:\n        return self._as / (self._as + self._bs)\n\n    def run_one_step(self) -&gt; tuple[int, float]:\n        samples = self.rng.beta(self._as, self._bs)\n\n        # tie-breaking\n        candidates = np.flatnonzero(samples == samples.max())\n        i = int(self.rng.choice(candidates))\n\n        r = self.bandit.generate_reward(i)\n\n        self._as[i] += r\n        self._bs[i] += 1 - r\n\n        return i, r"
  },
  {
    "objectID": "posts/2025-05-07-ministate-v3/index.html",
    "href": "posts/2025-05-07-ministate-v3/index.html",
    "title": "Building a No‑Fluff Report Template in LaTeX",
    "section": "",
    "text": "Dense (less fluff) — Every square centimeter should serve the reader. Tighter vertical spacing and compact headings keep the narrative flowing.\nOptional titles — Some documents benefit from title; others (like a few‑paragraph conclusion) do not. The template should let me toggle them off with a single flag.\nFlexible — Today, I might need a one‑pager. Tomorrow, a 20‑page appendix. Layout decisions (margins, font, color) should be parameterized — not hard‑wired.\n\nExisting classes like article or even IEEEtran come close but still force in essential baggage (abstract blocks, keywords, etc.). Then I stumbled upon the elegant ministate class. So I adapted it."
  },
  {
    "objectID": "posts/2025-05-07-ministate-v3/index.html#why-a-new-template",
    "href": "posts/2025-05-07-ministate-v3/index.html#why-a-new-template",
    "title": "Building a No‑Fluff Report Template in LaTeX",
    "section": "",
    "text": "Dense (less fluff) — Every square centimeter should serve the reader. Tighter vertical spacing and compact headings keep the narrative flowing.\nOptional titles — Some documents benefit from title; others (like a few‑paragraph conclusion) do not. The template should let me toggle them off with a single flag.\nFlexible — Today, I might need a one‑pager. Tomorrow, a 20‑page appendix. Layout decisions (margins, font, color) should be parameterized — not hard‑wired.\n\nExisting classes like article or even IEEEtran come close but still force in essential baggage (abstract blocks, keywords, etc.). Then I stumbled upon the elegant ministate class. So I adapted it."
  },
  {
    "objectID": "posts/2025-05-07-ministate-v3/index.html#meet-ministate-v3.0",
    "href": "posts/2025-05-07-ministate-v3/index.html#meet-ministate-v3.0",
    "title": "Building a No‑Fluff Report Template in LaTeX",
    "section": "Meet ministate v3.0",
    "text": "Meet ministate v3.0\n\n\nministate.cls\n\n\\ProvidesClass{ministate}[2023/03/29 v3.0 Minimalist statement class]\n\\LoadClass[11pt,a4paper]{article}\n\n\\usepackage[utf8]{inputenc} % from 2018, UTF-8 is default in LaTeX\n\\usepackage[T1]{fontenc}\n\\usepackage{lmodern}\n\n\\usepackage{microtype}\n\n\\usepackage[margin=0.8in]{geometry}\n\\usepackage{parskip}\n\\usepackage{fancyhdr}\n\n\\setlength{\\headheight}{15.2pt}\n\\pagestyle{fancy}\n\\fancyhf{} % Clear all header and footer fields\n\n%--------------------------------------------------%\n%    Title, HeaderTitle, Author, HeaderAuthor,     %\n%                 Custom Date                      %\n%--------------------------------------------------%\n\n\\let\\oldtitle\\title\n\\let\\oldauthor\\author\n\\let\\olddate\\date\n\n\\def\\@headertitle{}\n\\def\\@headerauthor{}\n\\def\\@headerdate{}\n\n% Redefine the \\title and \\author commands\n\\renewcommand{\\title}[1]{%\n    \\oldtitle{#1}%\n    \\ifx\\@headertitle\\@empty%\n        \\relax\\def\\@headertitle{#1}%\n    \\fi%\n}\n\\renewcommand{\\author}[1]{%\n    \\oldauthor{#1}%\n    \\ifx\\@headerauthor\\@empty%\n        \\relax\\def\\@headerauthor{#1}%\n    \\fi%\n}\n\n\\renewcommand{\\date}[1]{%\n    \\olddate{#1}%\n    \\ifx\\@headerdate\\@empty%\n        \\relax\\def\\@headerdate{#1}%\n    \\fi%\n}\n\n% Commands for explicitly setting the header title and header author\n\\newcommand{\\headertitle}[1]{\\def\\@headertitle{#1}}\n\\newcommand{\\headerauthor}[1]{\\def\\@headerauthor{#1}}\n\n\n\n\n\n\\fancypagestyle{ministate}{%\n  \\fancyhf{}% clear everything\n  \\fancyhead[L]{\\textbf{\\@headertitle}\\ifx\\@headerdate\\@empty\\else\\ (\\@headerdate)\\fi}%\n  \\fancyhead[R]{\\textbf{\\@headerauthor}}%\n  \\fancyfoot[C]{\\thepage}%\n}\n\n\\pagestyle{ministate}\n\n% Apply header settings including the custom date\n%\\fancyhead[L]{\\textbf{\\@headertitle}\\ifx\\@headerdate\\@empty\\else\\ (\\@headerdate)\\fi} % Title (Custom Date)\n%\\fancyhead[R]{\\textbf{\\@headerauthor}} % Author\n\n%\\fancyfoot{} % Override existing foot numbering\n%\\fancyfoot[C]{\\thepage} % Page number at center of footer\n\n\n%--------------------------------------------------%\n%                   Document Body                  %\n%--------------------------------------------------%\n\n% Usage:\n% \\title{Your Title Here}\n% \\author{Author Name}\n% \\headertitle{Your Header Title Here} - For custom header title\n% \\headerauthor{Your Header Author Here} - For custom header author\n% \\date{Custom Date or Empty String} - To change or remove the date\n\n% Comment this block if we don't want header on the first page\n\\usepackage{etoolbox}   % load before you patch anything\n\\makeatletter\n\\patchcmd{\\maketitle}%          the command to patch\n  {\\thispagestyle{plain}}%      code to replace\n  {\\thispagestyle{ministate}}%  replacement\n  {}{}                          % ← success / failure actions (empty)\n\\makeatother\n\n\n\\makeatletter\n\\def\\@maketitle{%\n  \\newpage\n  \\begin{center}%\n    \\let\\footnote\\thanks\n    {\\LARGE \\@title\\par}%\n    \\vskip 0.2em%\n    {\\large\\begin{tabular}[t]{c}\\@author\\end{tabular}\\par}%\n    \\vskip 0.2em%\n    {\\large \\@date}\\vskip 0.2em% % Commented out to remove the date\n  \\end{center}%\n  \\par\n}%\n\\makeatother\n\nThe content of example.tex file:\n\n\nexample.tex\n\n\\documentclass[11pt,a4paper,nonatbib]{./ministate}\n\n% (optional) bibliography\n%\\usepackage[backend=biber,style=ieee,autocite=plain,sorting=none]{biblatex}\n%\\addbibresource{biblio.bib}\n\\usepackage[sfdefault]{atkinson}\n\\usepackage{fontawesome}\n\n\\usepackage{hyperref}\n\\usepackage{url}\n\n\\usepackage[english]{babel}\n\\usepackage[autostyle,english=british]{csquotes}\n\n% (optional) prevent breaking words\n\\usepackage[none]{hyphenat}\n\\interdisplaylinepenalty=10000\n\n% lorem ipsum generator\n\\usepackage{kantlipsum}\n\n\n% ministate settings\n\\title{The Summary of Lorem Ipsum}\n\\headertitle{The Shorter Title}  % (optional) will use \\title if not used\n\n\\author{Johnny English, PhD}\n\\headerauthor{Johnny E., PhD} % (optional) will use \\author if not used\n\n\\date{May 7, 2025}\n\n\\begin{document}\n\n\\maketitle\n\n\\kant\n\n%\\clearpage\n%\\printbibliography[title={Osebna bibliografija}]\n\n\\end{document}\n\n\nOutcome\nBelow, I embedded the outcome PDF of the above code samples …"
  },
  {
    "objectID": "posts/2023-11-20-research-compute-infrastructure/index.html",
    "href": "posts/2023-11-20-research-compute-infrastructure/index.html",
    "title": "Research Compute Infrastructure",
    "section": "",
    "text": "Recent technological advances have transformed education, elevating the quality of teaching and learning. Jupyter Notebooks emerge as a leading tool for interactive computing, programming, and data analysis (Perkel 2018; Mendez et al. 2019; Granger et al. 2021). However, hardware limitations became a significant hurdle when handling larger research projects. While public cloud services are an option, they come with notable drawbacks. In response, we developed a private cloud solution for our lab using Kubernetes. This solution addresses cost and security concerns while ensuring adaptability. Through this technology, we have enabled efficient app management, scalability, and resource flexibility.\n\n\nA Jupyter Notebook is an open document format based on JSON1. Notebooks are organized into a sequence of cells, with each cell containing code, descriptive text, equations, and rich outputs (e.g., text displays, tables, audio, images, and animations). Tools like JupyterLab provide a platform for interactive code execution, data analysis, and documentation, all within a single interface, culminating in a Jupyter Notebook. These notebooks support various programming languages (e.g., Python, R, Scala, C++) and allow users to write and execute code cells iteratively (using REPL2 or WETL3 approaches), offering immediate visibility of intermediate results. This facilitates the creation of narrative-driven data analyses, educational materials, and interactive presentations. Due to their versatility and interactivity, Jupyter Notebooks are a robust teaching tool for learning, conducting data science, and computer research.\nBecause of these remarkable features, we decided to incorporate Jupyter Notebooks into research lab’s educational and research processes. We started to encourage students and researchers to use Jupyter notebooks to document research to more easily share it others.\n\n\n\nHowever, for large-scale projects involving hefty data processing on personal computers, using Jupyter Notebooks becomes a significant challenge. We frequently run into hardware limitations like storage space, RAM, processing power, and access to computational accelerators, which can hinder or even halt our progress. These projects are typically in the early stages of research, analysis, or prototyping, so intensive optimizations are impractical because they can slow down experimental development. Two potential solutions emerge: running Jupyter Notebooks on the grid, HPC infrastructure, or cloud services.\nHPC infrastructure, like SLING in Slovenia or EuroHPC on a European level, offers immense computational power. However, given that HPCs are significant investments, queue management solutions like SLURM are employed in the HPC world to optimize their use. Computation tasks must be pre-packaged with metadata, code, and input data. These tasks then join a waiting list. This approach is not aligned well with data-driven research, which aims for interactive programming and quick feedback, limiting the full utilization of Jupyter Notebooks. Hence, cloud services become a more common choice for these notebooks.\nPublic cloud platforms like Google Colab and Kaggle have popularized Jupyter Notebook usage. Users can access the service anytime without queues, edit notebooks, and utilize cloud computing resources, all via a browser. Both services are freely accessible in a limited version. However, due to high user demand, these platforms sometimes limit computational resources, affecting service quality. Alternatives include custom paid services in the public cloud (e.g., AWS, Azure, GCP, Alibaba Cloud), tailoring infrastructure to customer needs. However, public cloud services have drawbacks, including high rental costs, unpredictable market-affected expenses, and security concerns when handling sensitive data.\nPrivate clouds are an alternative to the public cloud, addressing cost and security challenges. They are crucial for research labs and companies dealing with sensitive data or requiring high adaptability. It grants organizations more transparency and cost control based on their needs and capabilities. Despite the initial technical knowledge and infrastructure investment requirements, private clouds offer enhanced security, control, and flexibility, leading to more predictable costs in the long run.\nSeveral technologies are available to set up a private cloud, including commercial options (e.g., VMware vSphere, Red Hat OpenShift, IBM Cloud Private) and open-source solutions (e.g., The Littlest JupyerHub, OpenStack, Eucalyptus, Kubernetes, or using Docker Compose [reference design, gcerar/jupyterhub-docker]). Among the open-source options, Kubernetes is the most popular solution.\nKubernetes (abbreviated as K8s) is an open-source platform designed for the automation, management, and deployment of applications within containers. Its advanced orchestration features allow for efficient application management, automatic scaling, monitoring of their performance, and high availability. It can simplify the development and maintenance of complex cloud-based applications.\nContrary to Docker and Docker Compose, which primarily focus on building, storing, and running individual containers, Kubernetes offers a much more comprehensive platform for managing containers across expansive environments that span multiple computing nodes. While Docker provides easy creation and operation of individual containers, and docker-compose allows defining multiple containers as application units, Kubernetes facilitates the management of entire clusters of these application units throughout their life cycle, which includes automatic deployment, dynamic adjustments based on load, recovery in case of errors, and more advanced service and network management.\nIn our research lab, due to the growing computational demands prevalent in data science and the desire to retain the recognizable workflow present in Jupyter notebooks, we have developed our private cloud solution based on Kubernetes technology.\nThe following sections will present a private cloud setup featuring Jupyter notebooks built on top of open-source solutions. The user experience closely resembles that of existing paid cloud services. The private cloud must meet the following requirements:\n\nSystem Scalability: The cloud should allow for easily adding computing nodes to the cluster without disrupting the operational system, supporting larger research projects or teaching groups.\nEfficient Resource Management: The system must enable precise allocation of resources to users. In this context, an administrator can define a balance between a lax and strict resource allocation policy.\nEnhanced Collaboration Experience: The system should allow for straightforward sharing of Jupyter notebooks among users, promoting collaboration on joint projects and idea exchange between researchers and students.\nNo Waiting Queues: The system should eliminate waiting queues, offering users immediate access to computational resources to the best of their capacity."
  },
  {
    "objectID": "posts/2023-11-20-research-compute-infrastructure/index.html#jupyter-notebooks",
    "href": "posts/2023-11-20-research-compute-infrastructure/index.html#jupyter-notebooks",
    "title": "Research Compute Infrastructure",
    "section": "",
    "text": "A Jupyter Notebook is an open document format based on JSON1. Notebooks are organized into a sequence of cells, with each cell containing code, descriptive text, equations, and rich outputs (e.g., text displays, tables, audio, images, and animations). Tools like JupyterLab provide a platform for interactive code execution, data analysis, and documentation, all within a single interface, culminating in a Jupyter Notebook. These notebooks support various programming languages (e.g., Python, R, Scala, C++) and allow users to write and execute code cells iteratively (using REPL2 or WETL3 approaches), offering immediate visibility of intermediate results. This facilitates the creation of narrative-driven data analyses, educational materials, and interactive presentations. Due to their versatility and interactivity, Jupyter Notebooks are a robust teaching tool for learning, conducting data science, and computer research.\nBecause of these remarkable features, we decided to incorporate Jupyter Notebooks into research lab’s educational and research processes. We started to encourage students and researchers to use Jupyter notebooks to document research to more easily share it others."
  },
  {
    "objectID": "posts/2023-11-20-research-compute-infrastructure/index.html#scalability",
    "href": "posts/2023-11-20-research-compute-infrastructure/index.html#scalability",
    "title": "Research Compute Infrastructure",
    "section": "",
    "text": "However, for large-scale projects involving hefty data processing on personal computers, using Jupyter Notebooks becomes a significant challenge. We frequently run into hardware limitations like storage space, RAM, processing power, and access to computational accelerators, which can hinder or even halt our progress. These projects are typically in the early stages of research, analysis, or prototyping, so intensive optimizations are impractical because they can slow down experimental development. Two potential solutions emerge: running Jupyter Notebooks on the grid, HPC infrastructure, or cloud services.\nHPC infrastructure, like SLING in Slovenia or EuroHPC on a European level, offers immense computational power. However, given that HPCs are significant investments, queue management solutions like SLURM are employed in the HPC world to optimize their use. Computation tasks must be pre-packaged with metadata, code, and input data. These tasks then join a waiting list. This approach is not aligned well with data-driven research, which aims for interactive programming and quick feedback, limiting the full utilization of Jupyter Notebooks. Hence, cloud services become a more common choice for these notebooks.\nPublic cloud platforms like Google Colab and Kaggle have popularized Jupyter Notebook usage. Users can access the service anytime without queues, edit notebooks, and utilize cloud computing resources, all via a browser. Both services are freely accessible in a limited version. However, due to high user demand, these platforms sometimes limit computational resources, affecting service quality. Alternatives include custom paid services in the public cloud (e.g., AWS, Azure, GCP, Alibaba Cloud), tailoring infrastructure to customer needs. However, public cloud services have drawbacks, including high rental costs, unpredictable market-affected expenses, and security concerns when handling sensitive data.\nPrivate clouds are an alternative to the public cloud, addressing cost and security challenges. They are crucial for research labs and companies dealing with sensitive data or requiring high adaptability. It grants organizations more transparency and cost control based on their needs and capabilities. Despite the initial technical knowledge and infrastructure investment requirements, private clouds offer enhanced security, control, and flexibility, leading to more predictable costs in the long run.\nSeveral technologies are available to set up a private cloud, including commercial options (e.g., VMware vSphere, Red Hat OpenShift, IBM Cloud Private) and open-source solutions (e.g., The Littlest JupyerHub, OpenStack, Eucalyptus, Kubernetes, or using Docker Compose [reference design, gcerar/jupyterhub-docker]). Among the open-source options, Kubernetes is the most popular solution.\nKubernetes (abbreviated as K8s) is an open-source platform designed for the automation, management, and deployment of applications within containers. Its advanced orchestration features allow for efficient application management, automatic scaling, monitoring of their performance, and high availability. It can simplify the development and maintenance of complex cloud-based applications.\nContrary to Docker and Docker Compose, which primarily focus on building, storing, and running individual containers, Kubernetes offers a much more comprehensive platform for managing containers across expansive environments that span multiple computing nodes. While Docker provides easy creation and operation of individual containers, and docker-compose allows defining multiple containers as application units, Kubernetes facilitates the management of entire clusters of these application units throughout their life cycle, which includes automatic deployment, dynamic adjustments based on load, recovery in case of errors, and more advanced service and network management.\nIn our research lab, due to the growing computational demands prevalent in data science and the desire to retain the recognizable workflow present in Jupyter notebooks, we have developed our private cloud solution based on Kubernetes technology.\nThe following sections will present a private cloud setup featuring Jupyter notebooks built on top of open-source solutions. The user experience closely resembles that of existing paid cloud services. The private cloud must meet the following requirements:\n\nSystem Scalability: The cloud should allow for easily adding computing nodes to the cluster without disrupting the operational system, supporting larger research projects or teaching groups.\nEfficient Resource Management: The system must enable precise allocation of resources to users. In this context, an administrator can define a balance between a lax and strict resource allocation policy.\nEnhanced Collaboration Experience: The system should allow for straightforward sharing of Jupyter notebooks among users, promoting collaboration on joint projects and idea exchange between researchers and students.\nNo Waiting Queues: The system should eliminate waiting queues, offering users immediate access to computational resources to the best of their capacity."
  },
  {
    "objectID": "posts/2023-11-20-research-compute-infrastructure/index.html#turnkey-solution",
    "href": "posts/2023-11-20-research-compute-infrastructure/index.html#turnkey-solution",
    "title": "Research Compute Infrastructure",
    "section": "Turnkey Solution?",
    "text": "Turnkey Solution?\nWhen planning the private cloud, we initially explored turnkey solutions, including NVIDIA DeepOps. Despite its advantages, we built our custom solution for the following reasons. While DeepOps is an excellent turnkey solution with maintained source code on GitHub and offers commercial support, initial setup requires configuration file adjustments, including Ansible scripts for automated (re)configuration of installed Linux distribution. Its complexity discouraged us, further investing our time into tinkering with it.\nOne of our biggest concerns was the intricate solution that tries to be versatile and “simple”. However, this inevitably leads to hiding functionalities and, in case of issues, jumping around documentation of multiple unrelated internally used tools. Despite proclaimed simplicity, troubleshooting or upgrade problems require manual intervention, where a thorough understanding of Linux, DeepOps, its internal tooling, and their interactions is necessary for system control. Therefore, we decided to start with a minimalist solution and, over time, plan to expand the system to understand the infrastructure’s operation better."
  },
  {
    "objectID": "posts/2023-11-20-research-compute-infrastructure/index.html#foundation-infrastructure",
    "href": "posts/2023-11-20-research-compute-infrastructure/index.html#foundation-infrastructure",
    "title": "Research Compute Infrastructure",
    "section": "Foundation Infrastructure",
    "text": "Foundation Infrastructure\nIn this section, we discuss the foundation infrastructure of our private cloud solution. We’ll go through these building blocks, including the selection of container management tools and resource sharing, which are vital for the operation of the Kubernetes platform.\nOperating System: We chose Ubuntu Server based on the Debian Linux distribution for our system. The advantage of widely used Debian-based Linux distributions is the abundance of available knowledge resources and support, making problem-solving more accessible. Among alternatives, like declarative binary reproducible NixOS and RHEL-based distributions, we also considered the Talos distribution specialized for Kubernetes. However, we preferred to stick with Ubuntu Server due to the Talos project’s novelty and associated risks.\nContainer Management: For container management, we selected ContainerD, also used in the DeepOps solution and officially supported by NVIDIA. It is an open-source tool that implements the CRI interface for communication between the operating system and Kubernetes for efficient and reliable container management.\nData Storage: For data storage, we chose ZFS, which resides on one of the nodes. Although solutions like HDFS, Gluster, Lustre, or Ceph are far more common in the HPC world, they require dedicated infrastructure and tools to offer features offered by ZFS out-of-the-box. Features include checkpoints, data deduplication, compression, a COW (copy-on-write) system to prevent data loss during writing, immunity to silent bit-rot, the ability to use disks as redundancy for mechanical failures, and the use of fast SSD devices as a cache. It also allows easy manual intervention in the event of incidents. However, at the time of writing, ZFS does not stretch across multiple nodes, posing a risk of cluster failure in case of a data-storing node’s malfunction (single point of failure). There is an ongoing effort to implement ZFS’ distributed RAID (dRAID) [src].\nTo access ZFS storage from Kubernetes, we used the NFS server, which is part of the Linux kernel. We chose NFS because it is one of the few methods that allow multiple containers to bind to the same mounting point (see table).\nSystem Management: For remote management and node configuration, we use Ansible maintained by Red Hat. We selected it due to its prevalence in other significant open-source projects and positive experiences from past projects."
  },
  {
    "objectID": "posts/2023-11-20-research-compute-infrastructure/index.html#kubernetes",
    "href": "posts/2023-11-20-research-compute-infrastructure/index.html#kubernetes",
    "title": "Research Compute Infrastructure",
    "section": "Kubernetes",
    "text": "Kubernetes\nIn Kubernetes, everything operates as a service. These services provide various functionalities that enhance Kubernetes capabilities, such as storage access, CPU and GPU allocation, traffic management, and connecting services within a mesh network.\nTo support specific functionalities, appropriate services (much like operating system drivers) must be installed. These specialized services, often called “operators” in Kubernetes terminology [src], are essential. They not only deploy and manage functionalities but also respond to issues. Operators enhance Kubernetes by interfacing with standardized and version-controlled APIs.\nPut simply, operators can be viewed as one or more Docker containers. They function as an intermediary layer, bridging the gap between the underlying operating system and Kubernetes APIs.\n\nInternal Services\nIn Kubernetes, internal services are not intended for end users but are crucial for the system’s operation. These services operate in the background, ensuring vital functionalities that enable the stable operation and management of the container environment. In this subsection, we will introduce key services within Kubernetes and explain their role in our infrastructure. We will describe each service’s primary functionality and examine alternatives we explored in making our decision.\nKubernetes Distribution: When choosing a Kubernetes distribution, we examined three options: Canonical MicroK8s, Red Hat OpenShift, and the basic “vanilla” Kubernetes distribution. “Vanilla” Kubernetes represents the unaltered version directly available in Google’s repository, without pre-installed applications or plugins. We went for the vanilla version as it provides flexibility and freedom of choice of the extensions.\nMicroK8s is an excellent solution for quick experimentation and setting up the system on smaller devices with limited resources (e.g., Raspberry Pi). However, it has many pre-installed applications and uses Canonical’s Snap packaging system, which can complicate adjusting configuration files and accessing external services, such as the NFS server.\nWe ruled out OpenShift due to the complexity of managing security profiles that, for our use case, were excessive, requiring substantial effort to implement these profiles for each service. Therefore, we opted for the basic “vanilla” Kubernetes distribution, offering more flexible and straightforward customization tailored to our needs.\nKubernetes Package Deployment: To describe the implementation of services in Kubernetes, a straightforward approach is to write YAML configuration file(s) (also called manifesto), which are then forwarded to Kubernetes via the command line. However, some services can be quite complex, leading developers to create service packages, making services more general-purpose and customizable through parameters. The most widespread packaging system is Helm, allowing for more portable and adaptable service packages. Helm uses YAML files as templates (much like forms), which are then filled out based on the provided parameters and sent to Kubernetes.\nNetwork Operator: Kubernetes services must be interconnected to communicate with other services. We opted for the open-source Tigera Calico operator to manage interconnections. Given its prevalence and functionalities, we found it the most suitable solution.\nCalico and Flannel are the most common solutions for network operators. Flannel is more minimalistic and operates as a network switch (layer 2) using technologies like Open vSwitch or VXLAN. In contrast, Calico routes traffic like a network router (layer 3). Especially in cases of multi-cluster (i.e., multiple physical locations) or hybrid cloud services, Calico emerges as a better choice.\nStorage Operator: For effective storage management within the Kubernetes system, we used csi-driver-nfs. It allows us to use the already established NFS servers. With it, we ensure uninterrupted access to persistent storage for any service within our private cloud.\nThe csi-driver-nfs proved most suitable since we already had an NFS server on one of the nodes. It allows us straightforward and centralized storage management for all services within Kubernetes. Centralization brings about numerous advantages, yet also challenges. Among the latter is the system’s vulnerability during a potential outage of the node storing the data. Nonetheless, centralization facilitates easier troubleshooting and backup execution.\nBare-Metal Ingress Load-Balancer: To ensure balanced ingress (of incoming) traffic among entry points in our Kubernetes cluster, we decided to utilize the MetalLB solution. After thorough research, we could not find any other alternative. Most of the online documentation (e.g., tutorials, blogs) focuses on setting up infrastructure on public clouds such as AWS or Azure and using solutions tailored to the demands of public cloud providers. However, since our infrastructure is based on our hardware (i.e., bare-metal), we opted for MetalLB, which has proven reliable and effective in routing traffic among our Kubernetes cluster’s entry points.\nIngress Operator: While a network operator manages interconnection between services within Kubernetes, the ingress operator manages access to services from the outside world. For security reasons, direct access to the internal network is prohibited. While it is possible to enter the internal network through a proxy (i.e., kubectl proxy), that’s meant only for debugging purposes. The ingress operator is designed to resolve domain names and route traffic to the correct container and port, which we described in the service’s YAML manifesto. Using domain name resolution has several advantages. Regardless of the service’s internal IP address, the ingress operator will always correctly direct traffic. The ingress operator can act as a load balancer when there is a high-traffic load, balancing traffic between multiple copies of service.\nAmong the most common solutions for ingress traffic management are NGINX and Traefik Ingress Operator. We chose NGINX, but the operators’ interface is standardized, so there are almost no differences between the solutions. Regardless of the selected solution, once a new service is deployed, the operator will follow the service’s manifesto and automatically route traffic to the appropriate container.\nGPU Operator: For efficient management of access to computing accelerators, we decided to use the official NVIDIA GPU-Operator suite of services. This suite provides two distinct installation options for NVIDIA drivers. The first option leverages host drivers, while the second involves drivers packaged within containers. Initially, we opted for the first option, wanting to enable the use of accelerators outside the Kubernetes framework. However, due to issues with conflicting driver versions, we decided to utilize the drivers provided by the GPU-Operator.\n\n\nUser Services\nIn this section, we introduce the selected services available to end users of our private cloud, enabling efficient execution and management of their research and educational projects.\nJupyterHub represents one of the key services in our private cloud, providing users with easy access to computing resources, data, and Jupyter notebooks for research and teaching purposes. To implement JupyterHub, we use the Z2JH (Zero-to-JupyterHub) implementation, developed by a team of researchers at the University of Berkeley in collaboration with the Jupyter community. This solution facilitates quick setup and maintenance.\nEvery individual user is granted access to an isolated container instance via their username and password or OAuth provider, such as GitHub, Google, or OAuth0. An isolated instance offers a stripped-down Linux environment with limited internet access and without admin permissions. Kubernetes then ensures access to shared data resources, common directories, and the use of computational accelerators.\nThe JupyterHub user interface is similar to Google Colab or Kaggle services. Upon entering the isolated instance, JupyterLab is already running, and the user also has access to the Linux terminal. Additional tools and software packages can be installed using pip, conda, or mamba commands.\nGrafana is a key service in our private cloud, facilitating a straightforward display of the current workload of the compute cluster and the availability of computational accelerators. This data visualization platform allows users to present information clearly and transparently, aiding them in making decisions regarding resource usage and optimizing their tasks. Utilizing Grafana ensures efficient and transparent resource monitoring, enhancing user experience. Data collection (Prometheus) and visualization (Grafana) are deployed by kube-prometheus-stack."
  },
  {
    "objectID": "posts/2023-11-20-research-compute-infrastructure/index.html#hardware",
    "href": "posts/2023-11-20-research-compute-infrastructure/index.html#hardware",
    "title": "Research Compute Infrastructure",
    "section": "Hardware",
    "text": "Hardware\n\n\n\nTable 2: Hardware specifications of Computing node.\n\n\n\n\n\nHardware\nSpecifications\n\n\n\n\nChasis\nSupermicro A+ Server 4124GS-TNR, 4U size, up to PCI-E 8 GPUs\n\n\nCPU\n2x AMD EPYC 75F3 (32C/64T, up to 4.0GHz, 256MB L3 cache)\n\n\nMemory\n1TB (16x64GB) REG ECC DDR4, 3200MHz\n\n\nSystem\n2x 2TB SSD NVMe, software RAID-1 (mirror)\n\n\nStorage\n6x 8TB SSD SATA, software RAID-Z1 (1 disk redundancy)\n\n\nGPU\n2x NVIDIA A100 80GB PCI-E\n\n\n\n\n\n\nWhen we bought the hardware in early 2022, we chose third-generation AMD EPYC processors. Specifically, we went for the F-series, which has higher base and turbo frequencies — up to 4.0GHz — at the cost of fewer cores. We picked a CPU with the highest available TDP of 280W. We installed server-grade registered error-correcting memory at the highest frequency supported by the processor and populated all eight channels on both processors. Sixteen sticks of RAM in total. Although we considered solutions from Intel, AMD EPYC processors had better price-to-performance ratios.\nFrom the perspective of numerical performance, our significant concern was Intel-optimized libraries, such as Intel MKL, often found in numerical tools. The library has a “bug” that causes non-Intel processors to utilize a slower SSE instead of more advanced AVX vectorization instructions [src]. OpenBLAS is a good alternative but requires some effort to install it. See Anaconda no-mkl package.\nWe chose two NVMe drives configured in the mirror configuration (RAID-1) for the system drive. We selected six 8TB SSD SATA drives configured in ZFS RAID-Z1 for data storage, which has one drive redundancy. We also chose two A100 GPUs as accelerators.\nNVIDIA A100 GPUs come in two form factors: PCI-E and SXM4. The SXM4 proprietary form factor has a higher TDP and high-bandwidth NVLink interconnections between every GPU through NVSwitch hardware. The downside of SXM4 is that it will only support Ampere generation GPUs and require a special motherboard. The PCI-E variant has a lower TDP, and NVLink can only be across two GPUs. However, we decided against vendor lock-in, limiting ourselves to one brand and generation, and went with the PCI-E variant.\nWe considered the most likely workflow scenarios. We expected most communication to be CPU-to-GPU, with GPUs sliced into several instances. Once GPU slicing is enabled, the NVIDIA drivers disable NVLink, rendering NVLink connections useless. We can change GPU slicing strategy freely.\n\n\n\n\n\n\nFigure 2: The computing node on my desk underwent final checks before being installed in the server rack."
  },
  {
    "objectID": "posts/2023-11-20-research-compute-infrastructure/index.html#user-experience",
    "href": "posts/2023-11-20-research-compute-infrastructure/index.html#user-experience",
    "title": "Research Compute Infrastructure",
    "section": "User Experience",
    "text": "User Experience\nAfter deploying the hardware and software stack, we conducted a month-long live test to stabilize the configuration. During this period, users were informed that we might reboot the system or make significant changes without responsibility for any potential data loss, though we aimed to minimize such occurrences.\nWe made two key decisions about resource allocation. Users can utilize all available memory and CPU cores. When CPU demand is high, Kubernetes and the operating system manage the scheduling of tasks. In cases of high memory usage, the job consuming the most memory is terminated to protect other running tasks.\nFeedback from students and researchers was overwhelmingly positive, highlighting the high speed, numerous cores, ample memory, and dedicated GPU access without interference.\nDuring the testing phase, “testers” identified several issues, which were promptly addressed. These included adding a shared folder with datasets and Jupyter notebooks, shared package cache, and better persistence of running tasks in JupyterLab.\n\nJupyterHub\nJupyterHub has become a crucial component of our research infrastructure, enhancing our workflow significantly. Its smooth integration was largely due to the interface and functionality of JupyterHub, which closely resemble the tools our researchers and students were familiar with. This similarity played a key role in its quick adoption and high user satisfaction.\n\n\n\n\n\n\nFigure 3: JupyterHub offers a list of predefined containers, where some of them offer a GPU instance.\n\n\n\nUpon logging into JupyterHub, users are presented with a list of predefined containers (as shown in Figure 3). Our recent update includes several options:\n\nA basic minimal working environment environment.\nA comprehensive data science environment equipped with multiple packages and support for Python, R, and Julia.\nA selection of containers offering GPU instances.\n\nThe development environment greets users with a layout similar to modern IDEs, featuring a file explorer on the left and code editor tabs on the right (see Figure 4).\n\n\n\n\n\n\nFigure 4: JupyterLab workspace with familiar layout: a file explorer on the left and code editor tabs on the right.\n\n\n\n\n\nGrafana\nFor transparent insight into infrastructure availability, the user has read-only access to the Grafana dashboard (Figure~\\(\\ref{fig:grafana:dashboard}\\)). Here, they can observe most of the infrastructure metrics.\nFor transparent insight into infrastructure availability, the user has read-only access to the Grafana dashboard. Dashboard visualizes computing resource utilization including metrics like total and per-container CPU usage, memory usage per container, GPU utilization, temperature readings, and storage I/O (see Figure 5).\n\n\n\n\n\n\nFigure 5: Visualization of computing cluster utilization showing total and per-container CPU utilization, per-container memory utilization, GPU slices utilization, temperatures, and storage I/O."
  },
  {
    "objectID": "posts/2023-11-20-research-compute-infrastructure/index.html#footnotes",
    "href": "posts/2023-11-20-research-compute-infrastructure/index.html#footnotes",
    "title": "Research Compute Infrastructure",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nJSON: JavaScript Object Notation↩︎\nREPL: read–eval–print loop↩︎\nWETL: write-eval-think-loop↩︎"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Gregor Cerar, PhD",
    "section": "",
    "text": "Hi 🖐️! I’m Gregor (Greg for short). I’m a Research & Innovation Engineer at Comsensus and a Postdoc / Professional Research Fellow at Jožef Stefan Institute, working with SensorLab.\nMost of my time, I work as a generalist Python developer. I write software for backend services, tools for interacting with hardware, and task automation. I occasionally work on AI tasks and deal with Linux, containers, Kubernetes and related tooling. I used to write embedded C and JavaScript, but now it’s mostly Python.\nI’m into self-supervised learning, time-series analysis, and smart infrastructure. I hold a PhD in ICT, where I focused on wireless communication and AI.\nBeyond work, I enjoy the quiet side of life. I like writing clean Python code, diving deep into research that interests me, and spending time outdoors hiking. I also enjoy playing chess and the classic “Uno!” card game.\nThanks for stopping by!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nReinforcement Learning: Tabular Q-Learning\n\n\n\ncode\n\npython\n\nmdp\n\n\n\nI’ve decided to start learning reinforcement learning with Frozenlake game and Q-Learning.\n\n\n\n\n\nDec 17, 2025\n\n4 min\n\n\n\n\n\n\n\n\n\n\n\nBernoulli Multi-Armed Bandit Problem\n\n\n\npython\n\ncode\n\nMAB\n\nreinforcement learning\n\n\n\nThe multi-armed bandit (MAB) problem is a classic reinforcement learning problem that illustrates the exploitation-exploration dilemma.\n\n\n\n\n\nDec 16, 2025\n\n18 min\n\n\n\n\n\n\n\n\n\n\n\nBuilding a No‑Fluff Report Template in LaTeX\n\n\n\nLaTeX\n\n\n\nOn a few occasions, I had to write a LaTeX/PDF report or documentation on what I was doing. I often got annoyed with TeX templates, which had lots of wasted whitespace around the title and edges of the document. So, I created a template that improves density, flexibility, and clarity.\n\n\n\n\n\nMay 7, 2025\n\n3 min\n\n\n\n\n\n\n\n\n\n\n\nVisualizing Feature Maps from VGG16 and ResNet50 in PyTorch\n\n\n\npytorch\n\nnn\n\n\n\nIn convolutional neural networks (CNNs), intermediate layers capture increasingly abstract representation of the input image. In this post, we visualize feature maps from VGG and ResNet using forward hooks in PyTorch.\n\n\n\n\n\nMay 6, 2025\n\n3 min\n\n\n\n\n\n\n\n\n\n\n\nResearch Compute Infrastructure\n\n\n\ncompute\n\ninfrastructure\n\n\n\nOur research lab needed a more scalable approach to sharing computing resources among researchers. To address this, we built a scalable computing infrastructure on Kubernetes. Researchers can request resources from the pool and use a familiar workflow with Jupyter notebooks. Resources are returned to the pool once a task is complete or idle for too long.\n\n\n\n\n\nNov 20, 2023\n\n23 min\n\n\n\n\n\n\n\n\n\n\n\nGenerative Adversarial Networks\n\n\n\npytorch\n\nGAN\n\n\n\nGenerative Adversarial Networks (GANs) represent an innovative class of unsupervised neural networks that have revolutionized the field of artificial intelligence. Eager to learn how they work, I’ve implemented foundational “vanilla” GAN and its more complex counterpart, the Deep Convolutional GAN (DCGAN), from scratch. I’ve put them on a test run on MNIST Digits and Fashion toy datasets.\n\n\n\n\n\nOct 10, 2023\n\n5 min\n\n\n\n\n\n\n\n\n\n\n\nNeural Style Transfer\n\n\n\npytorch\n\nNST\n\n\n\nNeural Style Transfer (NST) was a breakthrough deep learning approach that can transfer artistic style from one image to another. Eager to learn how it works, I’ve implemented the original approach from scratch.\n\n\n\n\n\nSep 15, 2023\n\n8 min\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2023-09-15-neural-style-transfer/index.html",
    "href": "posts/2023-09-15-neural-style-transfer/index.html",
    "title": "Neural Style Transfer",
    "section": "",
    "text": "Neural Style Transfer (NST) is a deep learning technique that combines the content of one image with the style of another, like giving your photo a Van Gogh-esque makeover.\nUsing convolutional neural networks, NST examines both images’ features and creates a new image that merges the content’s structure with the style’s attributes. This technique became a hit due to its novel outcomes, leading to its adoption in various apps and platforms and highlighting deep learning’s prowess in image transformation.\nIntroduced initially in “A Neural Algorithm of Artistic Style” (Gatys, Ecker, and Bethge 2015), this method transfers art styles between images. Eager to learn how it works, I’ve implemented the original approach from scratch and presented a few cherry-picked transformed examples."
  },
  {
    "objectID": "posts/2023-09-15-neural-style-transfer/index.html#loss-metrics",
    "href": "posts/2023-09-15-neural-style-transfer/index.html#loss-metrics",
    "title": "Neural Style Transfer",
    "section": "Loss metrics",
    "text": "Loss metrics\nTo effectively implement Neural Style Transfer, we need to quantify how well the generated image matches both the content and style of our source images. This is done using loss metrics. Let’s delve into the specifics of these metrics and how they drive the NST process.\n\nContent loss metric\nContent loss is calculated through Euclidean distance (i.e., mean squared error) between the respective intermediate higher-level feature representation \\(F^l\\) and \\(P^l\\) of original input image \\(\\vec{x}\\) and the content image \\(\\vec{p}\\) at layer \\(l\\).\nHence, a given input image \\(\\vec{x}\\) is encoded in each layer of the CNN by the filter responses to that image. A layer with \\(N_l\\) distinct filters has \\(N_l\\) feature maps of size \\(M_l\\), where \\(M_l\\) is the height times the width of the feature map. So the response in a layer \\(l\\) can be stored in a matrix \\(F^l \\in \\mathcal{R}^{N_l \\times M_l}\\) where \\(F_{ij}^{l}\\) is the activation of the \\(i^{th}\\) filter at position \\(j\\) in layer \\(l\\).\n\\[\n\\mathcal{L}_{content}(\\vec{p}, \\vec{x}, l) = \\frac{1}{2}\\sum_{i,j} (F^{l}_{ij} - P^{l}_{ij})^2\n\\]\n\ndef content_loss_func(target_features: dict[str, Tensor], precomputed_content_features: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Calculate content loss metric for give layers.\"\"\"\n\n    device = next(iter(target_features.values())).device\n    content_loss = torch.tensor(0.0, device=device)\n\n    for layer in precomputed_content_features:\n        target_feature = target_features[layer]\n        content_feature = precomputed_content_features[layer]\n\n        content_loss += F.mse_loss(target_feature, content_feature)\n\n    return content_loss\n\n\n\nStyle loss\nThe style loss is more convolved than the content loss. We compute it by comparing the Gram matrices of the feature maps from the style image and the generated image.\nFirst, let’s understand the Gram matrix. Given the feature map \\(F\\) of size \\(C \\times (H \\times W)\\), where \\(C\\) is the number of channels and \\(H \\times W\\) are the spatial dimensions, the Gram matrix \\(G\\) is of size \\(C \\times C\\) and is computed as\n\\[\nG^l_{ij} = \\sum_k F^l_{ik} F^l_{jk}\n\\]\nwhere \\(G_{ij}\\) is the inner product between vectorized feature maps \\(i\\) and \\(j\\). This results in a matrix that captures the correlation between different feature maps and, thus, the style information.\n\ndef gram_matrix(tensor: Tensor) -&gt; Tensor:\n    (b, c, h, w) = tensor.size()\n\n    # reshape into (C x (H x W))\n    features = tensor.view(b * c, h * w)\n\n    # compute the gram product\n    gram = torch.mm(features, features.t())\n\n    return gram\n\nThe style loss between the Gram matrix of the generated image \\(G\\) and that of style image \\(A\\) (at a specific layer \\(l\\)) is:\n\\[\nE_l = \\frac{1}{4 N^{2}_{l} M^{2}_{l}} \\sum_{i,j}(G^l_{ij} - A^l_{ij})^2\n\\]\nWhere \\(E_l\\) is the style loss for layer \\(l\\), \\(N_l\\) and \\(M_l\\) are the numbers of channels and height times width in the feature representation of layer \\(l\\), respectively. \\(G_{ij}^l\\) and \\(A_{ij}^l\\) are the gram matrices of the intermediate representation of the style image \\(\\vec{a}\\) and the input base image \\(\\vec{x}\\) respectively.\nThe total style loss is:\n\\[\n\\mathcal{L}_{style}(\\vec{a}, \\vec{x}) = \\sum_{l=0}^{L} w_l E_l\n\\]\n\ndef style_loss_func(\n    target_features: dict[str, Tensor], style_features: dict[str, Tensor], precomputed_style_grams: dict[str, Tensor]\n) -&gt; Tensor:\n    device = next(iter(target_features.values())).device\n    style_loss = torch.tensor(0.0, device=device)\n\n    for layer in style_features:\n        target_feature = target_features[layer]\n        target_gram = gram_matrix(target_feature)\n\n        style_gram = precomputed_style_grams[layer]\n\n        _, c, h, w = target_feature.shape\n\n        weight = STYLE_LAYERS_DEFAULT[layer]\n        layer_style_loss = weight * F.mse_loss(target_gram, style_gram) / (c * h * w)\n        style_loss += layer_style_loss\n\n    return style_loss\n\n\n\nTotal Variation Loss\nTotal Variation (TV) loss, also known as Total Variation Regularization, is commonly added to the Neural Style Transfer objective to encourage spatial smoothness in the generated image. Without it, the output might exhibit noise or oscillations, particularly in regions where the content and style objectives don’t offer much guidance.\nGiven an image \\(\\vec{x}\\) of size \\(H \\times W \\times C\\) (height, width, channels), the Total Variation loss is defined as the sum of the absolute differences between neighboring pixel values:\n\\[\n\\mathcal{L}_{TV}(\\vec{x}) = \\sum_{i,j} ((x_{i,j+1} - x_{i,j})^2 + (x_{i+1,j} - x_{i,j})^2)\n\\]\nwhere \\(x_{i,j}\\) is the pixel value at position \\((i,j)\\).\nIn simple terms, this loss penalizes abrupt changes in pixel values from one to its neighbors. By minimizing this loss, the generated image becomes smoother, reducing artifacts and unwanted noise. When combined with content and style losses, the TV loss ensures that the resulting image not only captures the content and style of the source images but also looks visually coherent and smooth.\n\ndef total_variance_loss_func(target: Tensor) -&gt; Tensor:\n    tv_loss = F.l1_loss(target[:, :, :, :-1], target[:, :, :, 1:]) + F.l1_loss(\n        target[:, :, :-1, :], target[:, :, 1:, :]\n    )\n\n    return tv_loss\n\n\n\nTotal Loss\nThe total loss combines three loss metric components, each targeting a specific aspect of the image generation process. Let’s recap the components:\n\nContent Loss: Ensures the generated image resembles the content image’s content.\nStyle Loss: Ensures the generated image captures the stylistic features of the style image.\nTotal Variation Loss: Encourages spatial smoothness in the generated image, reducing artifacts and noise.\n\nGiven the above components, the total loss \\(\\mathcal{L}_{total}\\) for Neural Style Transfer can be formulated as:\n\\[\n\\mathcal{L}_{total}(\\vec{p},\\vec{a},\\vec{x}) = \\alpha\\mathcal{L}_{content}(\\vec{p},\\vec{x}) + \\beta\\mathcal{L}_{style}(\\vec{a},\\vec{x}) + \\gamma\\mathcal{L}_{TV}(\\vec{x})\n\\]\n\\(\\alpha\\), \\(\\beta\\), and \\(\\gamma\\) are weight factors that determine the relative importance of the content, style, and the total variation losses, respectively. By adjusting these weights, one can control the balance between content preservation, style transfer intensity, and the smoothness of the generated image. The algorithm aims to adjust the generated image to minimize the total loss."
  },
  {
    "objectID": "posts/2023-09-15-neural-style-transfer/index.html#input-preparation",
    "href": "posts/2023-09-15-neural-style-transfer/index.html#input-preparation",
    "title": "Neural Style Transfer",
    "section": "Input preparation",
    "text": "Input preparation\nHere we specify path to content and style images:\n\ncontent_path = \"./bridge.jpg\"\nstyle_path = \"./walking-in-the-rain.jpg\""
  },
  {
    "objectID": "posts/2023-09-15-neural-style-transfer/index.html#neural-style-transfer-process",
    "href": "posts/2023-09-15-neural-style-transfer/index.html#neural-style-transfer-process",
    "title": "Neural Style Transfer",
    "section": "Neural Style Transfer Process",
    "text": "Neural Style Transfer Process\nFor feature extraction, we’ll leverage VGG19, pre-trained on ImageNet, same as the original authors. Note that we set the model to evaluation mode, ensuring we only use VGG19 to extract features without altering its weights. We also transfer the neural network (NN) to a chosen device, ideally a GPU, for optimal performance.\n\n\n\n\n\n\nNote\n\n\n\nAn intriguing choice by Gatys et al. was to modify VGG-19, replacing max pooling with average pooling, aiming for visually superior results. However, a challenge arises: our NN was initially trained with MaxPool2d layers. Substituting them can affect activations due to reduced output values. To counteract this, we’ve introduced a custom ScaledAvgPool2d.\n\n\n\n# We will use a frozen pre-trained VGG neural network for feature extraction.\n# In the original paper, authors have used VGG19 (without batch normalization)\nmodel = models.vgg19(weights=models.VGG19_Weights.IMAGENET1K_V1).features\n\n\n# Authors in the original paper suggested using AvgPool instead of MaxPool\n# for more pleasing results. However, changing the pooling also affects\n# activation, so the input needs to be scaled (can't find the original source).\nclass ScaledAvgPool2d(nn.Module):\n    def __init__(self, kernel_size, stride, padding=0, scale_factor=2.0):\n        super().__init__()\n        self.avgpool = torch.nn.AvgPool2d(kernel_size, stride, padding)\n        self.scale_factor = scale_factor\n\n    def forward(self, x):\n        return self.avgpool(x) * self.scale_factor\n\n\n# (OPTIONAL) Replace max-pooling layers with custom average pooling layers\n# for i, layer in enumerate(model):\n#   if isinstance(layer, torch.nn.MaxPool2d):\n#       model[i] = ScaledAvgPool2d(kernel_size=2, stride=2, padding=0)\n\nmodel = model.eval().requires_grad_(False).to(device)\n\nThe pretrained VGG model used normalized ImageNet samples for better performance. For effective style transfer, we’ll follow suit to improve feature extraction. Though images will appear altered post-normalization, they are reverted to their original state after the NST process. Next, we’ll transform the content and style images by:\n\nLoading them from storage.\nResizing while maintaining aspect ratio.\nConverting to tensors.\nNormalizing using ImageNet weights.\n\n\n# ImageNet normalization weights per channel\nIMAGENET_MEAN = (0.485, 0.456, 0.406)\nIMAGENET_STD = (0.229, 0.224, 0.225)\n\ntransform = T.Compose(\n    [\n        T.ToImage(),\n        T.Resize(IMG_SIZE),  # Shorter edge of the image will be matched to `IMG_SIZE`\n        T.ToDtype(torch.float32, scale=True),\n        T.Normalize(IMAGENET_MEAN, IMAGENET_STD),\n    ]\n)\n\n\ndef load_image(path: str | Path) -&gt; Tensor:\n    img = decode_image(str(path))\n\n    # Transform images into tensors\n    img: Tensor = transform(img)\n\n    # Add dimension to imitate batch size equal to 1: (C,H,W) -&gt; (B,C,H,W)\n    img = img.unsqueeze(0)\n    return img\n\nThe following code will prepares content \\(\\vec{p}\\), style \\(\\vec{a}\\), and target \\(\\vec{x}\\) images. The target image is a clone of the content image and we enable computation of gradients on it.\n\n# The \"style\" image from which we obtain style\nstyle = load_image(style_path).to(device)\n\n# The \"content\" image on which we apply style\ncontent = load_image(content_path).to(device)\n\n# The \"target\" image to store the outcome\ntarget = content.clone().requires_grad_(True).to(device)\n\nThe function below retrieves feature maps from designated layers. As shown in Figure 1:\n\nContent feature map comes from relu5_2.\nStyle feature maps are sourced from relu1_1, relu2_1, relu3_1, relu4_1, and relu5_1.\n\n\ndef get_features(image: Tensor, model: nn.Module, layers: Iterable[str] | None = None) -&gt; dict[str, Tensor]:\n    if layers is None:\n        layers = tuple(STYLE_LAYERS_DEFAULT.keys()) + CONTENT_LAYERS_DEFAULT\n\n    features = {}\n    block_num = 1\n    conv_num = 0\n\n    x = image\n\n    for layer in model.children():\n        x = layer(x)\n\n        if isinstance(layer, nn.Conv2d):\n            # produce layer name to find matching convolutions from the paper\n            # and store their output for further processing.\n            conv_num += 1\n            name = f\"conv{block_num}_{conv_num}\"\n            if name in layers:\n                features[name] = x\n\n        elif isinstance(layer, nn.MaxPool2d | nn.AvgPool2d | ScaledAvgPool2d):\n            # In VGG, each block ends with max/avg pooling layer.\n            block_num += 1\n            conv_num = 0\n\n        elif isinstance(layer, nn.BatchNorm2d | nn.ReLU):\n            pass\n\n        else:\n            raise Exception(f\"Unknown layer: {layer}\")\n\n    return features\n\nSince content and style images never change, we can precompute their feature maps and grams to speed up the NST process.\n\n# Precompute content features, style features, and style gram matrices.\ncontent_features = get_features(content, model, CONTENT_LAYERS_DEFAULT)\nstyle_features = get_features(style, model, STYLE_LAYERS_DEFAULT)\n\nstyle_grams = {layer: gram_matrix(style_features[layer]) for layer in style_features}\n\nNext, we will use Adam optimizer, where we specify that only target image \\(\\vec{x}\\) is considered for optimization.\n\noptimizer = optim.Adam([target], lr=LEARNING_RATE)\n\nThe final step of NST is to transfer style using everything we’ve implemented. We extract feature maps, compute total loss, perform steps using gradient descent, and repeat the process N_EPOCHS times. Gradient changes will apply only to the target image.\nTo notably enhance NST speed, I utilized mixed precision with the unique bfloat16 found in newer hardware. Traditional half-precision float16 doesn’t yield the same results. I’ve tested it. Probably because of the issue with gradient scaling.\n\npbar = tqdm(range(N_EPOCHS))\n\nfor _ in pbar:\n    with torch.autocast(\"cuda\", dtype=torch.bfloat16, enabled=AMP_ENABLED):\n        target_features = get_features(target, model)\n\n        content_loss = CONTENT_WEIGHT * content_loss_func(target_features, content_features)\n        style_loss = STYLE_WEIGHT * style_loss_func(target_features, style_features, style_grams)\n        tv_loss = TV_WEIGHT * total_variance_loss_func(target)\n\n        total_loss = content_loss + style_loss + tv_loss\n\n    optimizer.zero_grad()\n    total_loss.backward()\n\n    optimizer.step()\n\n    pbar.set_postfix_str(\n        f\"total_loss={total_loss.item():.2f} \"  # noqa: E501\n        f\"content_loss={content_loss.item():.2f} \"\n        f\"style_loss={style_loss.item():.2f} \"\n        f\"tv_loss={tv_loss.item():.2f}\"\n    )\n\n100%|██████████| 5000/5000 [01:37&lt;00:00, 51.45it/s, total_loss=43.91 content_loss=8.70 style_loss=29.11 tv_loss=6.11]     \n\n\nAs mentioned before, images need to be denormalized (i.e. reverted back) to correct colors. After that we compare content, style and target images side-by-side.\n\nclass InverseNormalize:\n    def __init__(self, mean: Sequence[float], std: Sequence[float]) -&gt; None:\n        self.mean = torch.as_tensor(mean)\n        self.std = torch.as_tensor(std)\n\n    def __call__(self, x_norm: Tensor) -&gt; Tensor:\n        # Ensure mean and std have the correct shape\n        mean = self.mean.to(x_norm.device).view(-1, 1, 1)\n        std = self.std.to(x_norm.device).view(-1, 1, 1)\n\n        # Inverse normalization: x = x_normalized * std + mean\n        x = x_norm.mul(std).add(mean)\n        return x\n\n\nclass Clip:\n    def __init__(self, vmin: float = 0.0, vmax: float = 1.0) -&gt; None:\n        self.vmin = vmin\n        self.vmax = vmax\n\n    def __call__(self, x: Tensor) -&gt; Tensor:\n        return torch.clamp(x, self.vmin, self.vmax)\n\n\ninv_transform_preview = T.Compose(\n    [\n        InverseNormalize(IMAGENET_MEAN, IMAGENET_STD),\n        T.Resize(IMG_SIZE, antialias=True),\n        T.CenterCrop((IMG_SIZE, IMG_SIZE)),\n        Clip(),\n    ]\n)\n\nimgs = [inv_transform_preview(i.detach().squeeze().cpu()) for i in (content, style, target)]\n\ngrid = make_grid(imgs)\n\n\ndef show(imgs):\n    if not isinstance(imgs, list):\n        imgs = [imgs]\n\n    fig, axs = plt.subplots(ncols=len(imgs), figsize=(15, 5), squeeze=False, dpi=92, tight_layout=True, frameon=False)\n    for i, img in enumerate(imgs):\n        img = img.detach()\n        img = VF.to_pil_image(img)\n        axs[0, i].imshow(np.asarray(img))\n        axs[0, i].set(xticklabels=[], yticklabels=[], xticks=[], yticks=[])\n\n\nshow(grid)\n\n\n\n\nSuccessfuly applied neural style transfer. The content image (left), the style image (center), and final target image (right)."
  },
  {
    "objectID": "posts/2023-09-15-neural-style-transfer/index.html#examples",
    "href": "posts/2023-09-15-neural-style-transfer/index.html#examples",
    "title": "Neural Style Transfer",
    "section": "Examples",
    "text": "Examples\nA few cherry-picked examples of style transfer:"
  },
  {
    "objectID": "posts/2025-05-06-feature-maps/index.html",
    "href": "posts/2025-05-06-feature-maps/index.html",
    "title": "Visualizing Feature Maps from VGG16 and ResNet50 in PyTorch",
    "section": "",
    "text": "Before we start, we need to install the following libraries: NumPy, Matplotlib, PyTorch, and Torchvision.\n\nimport math\nfrom collections.abc import Callable\nfrom pathlib import Path\nfrom typing import Literal\n\nimport numpy as np\nimport torch\nfrom IPython.display import Markdown\nfrom matplotlib import pyplot as plt\nfrom sklearn.decomposition import PCA\nfrom torch import Tensor, nn\nfrom torchvision import models\nfrom torchvision.io import decode_image\nfrom torchvision.transforms import v2 as T\n\nIn this article, we are going to use pre-trained neural networks. More specifically, weights trained on ImageNet-1K dataset.\nBut before that, we will prepare input images. We will size the image(s) to 224x224 and normalize it for optimal performance. The preparation step will make the pictures similar to the training dataset. See the link for more details on why this step is necessary.\n\n# ImageNet normalization weights per channel\nIMAGENET1K_MEAN = [0.485, 0.456, 0.406]\nIMAGENET1K_STD = [0.229, 0.224, 0.225]\n\ntransform = T.Compose(\n    [\n        T.Resize(256),\n        T.CenterCrop(224),\n        T.ToImage(),\n        T.ToDtype(torch.float32, scale=True),\n        T.Normalize(IMAGENET1K_MEAN, IMAGENET1K_STD),\n    ]\n)\n\n\ndef load_image(path: str | Path) -&gt; Tensor:\n    img = decode_image(str(path))\n\n    # Transform images into tensors\n    img: Tensor = transform(img)\n\n    # Add dimension to imitate batch size equal to 1: (C,H,W) -&gt; (B,C,H,W)\n    img = img.unsqueeze(0)\n    return img\n\n\ndef inverse_normalize(\n    x_norm: Tensor,\n    mean: list[float] = IMAGENET1K_MEAN,\n    std: list[float] = IMAGENET1K_STD,\n) -&gt; Tensor:\n    # Ensure mean and std have the correct shape\n    _mean = torch.as_tensor(mean).to(x_norm.device).view(1, -1, 1, 1)\n    _std = torch.as_tensor(std).to(x_norm.device).view(1, -1, 1, 1)\n    # Inverse normalization: x = x_normalized * std + mean\n    return x_norm.mul(_std).add(_mean)\n\n\nreverse_transform = T.Compose(\n    [\n        T.Lambda(inverse_normalize),\n        T.Lambda(lambda x: torch.clamp(x, min=0.0, max=1.0)),\n    ]\n)\n\n\nsample = load_image(\"bridge.jpg\")\norig_sample = reverse_transform(sample)\n\nfig, ax = plt.subplots(frameon=False)\nfig.subplots_adjust()\nax.imshow(orig_sample.squeeze(0).permute(1, 2, 0))\nax.axis(\"off\")\nplt.show()\n\n\n\n\nOriginal image, resized\n\n\n\n\n\ndef get_activation(name: str, activations: dict[str, Tensor]) -&gt; Callable:\n    def hook(model: nn.Module, tensor: Tensor, output: Tensor) -&gt; None:\n        # map layer's `name` to layer's output value\n        activations[name] = output.detach()\n\n    return hook\n\n\ndef set_hooks(model: nn.Module, layer_ids: list[str], out: dict[str, Tensor]) -&gt; None:\n    layer_ids = [str(i) for i in layer_ids]\n    for name, module in model.named_modules():\n        if name in layer_ids:\n            module.register_forward_hook(get_activation(name, out))\n\n\ndef visualize_feature_maps(\n    feature_map: Tensor | np.ndarray,\n    max_maps: int | None = None,\n    max_cols: int = 8,\n    figsize_per_plot: float = 1.0,\n    norm: Literal[\"linear\", \"log\", \"symlog\", \"logit\", None] = None,\n    cmap: str = \"viridis\",\n):\n    if isinstance(feature_map, Tensor):\n        feature_map = feature_map.cpu().numpy()\n\n    if feature_map.ndim == 4:\n        feature_map = feature_map.squeeze(0)  # remove batch dimension if present\n    assert feature_map.ndim == 3, \"Expected tensor shape (C, H, W)\"\n\n    C, H, W = feature_map.shape\n\n    if max_maps:\n        C = min(C, max_maps)\n\n    n_cols = min(C, max_cols)\n    n_rows = math.ceil(C / n_cols)\n\n    figsize = (figsize_per_plot * n_cols, figsize_per_plot * n_rows)\n\n    fig, axes = plt.subplots(nrows=n_rows, ncols=n_cols, figsize=figsize, frameon=False, squeeze=False)\n    fig.subplots_adjust(wspace=0.03, hspace=0.03)\n\n    for ax in axes.flat:\n        ax.axis(\"off\")\n\n    for i in range(C):\n        t = feature_map[i]\n        axes.flat[i].imshow(t, cmap=cmap, norm=norm, aspect=\"equal\", interpolation=\"none\")\n\n    return fig, axes\n\n\ndef minmax_scale_per_channel(arr: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Per-channel MinMax normalization. Expects (C, W, H).\"\"\"\n    assert arr.ndim == 3, f\"{arr.ndim=}\"\n\n    c_min = arr.min(axis=(1, 2), keepdims=True)\n    c_max = arr.max(axis=(1, 2), keepdims=True)\n    eps = 1e-5\n    scaled = (arr - c_min) / (c_max - c_min + eps)  # avoid division by zero\n    return scaled\n\n\ndef pca_rgb(\n    feature_map: np.ndarray | Tensor,\n    n_components: Literal[1, 3] = 3,\n    normalize: bool = True,\n    random_state: int | None = None,\n) -&gt; np.ndarray:\n    if isinstance(feature_map, torch.Tensor):\n        feature_map = feature_map.cpu().numpy()\n\n    if feature_map.ndim == 4:\n        feature_map = feature_map.squeeze(0)  # remove batch dimension if present\n    assert feature_map.ndim == 3, \"Expected array shape (C, H, W)\"\n\n    C, H, W = feature_map.shape\n    pca = PCA(n_components=n_components, random_state=random_state)\n    flat = feature_map.reshape(C, -1).T\n    rgb = pca.fit_transform(flat).T.reshape(n_components, H, W)\n\n    if normalize:\n        rgb = minmax_scale_per_channel(rgb)\n\n    return rgb\n\n\ndef visualize_feature_maps_pca(\n    feature_maps: dict[str, Tensor],\n    n_components: Literal[1, 3] = 3,\n    max_cols: int = 4,\n    figsize_per_plot: float = 2.0,\n    norm: Literal[\"linear\", \"log\", \"symlog\", \"logit\", None] = None,\n    subtitles: bool = True,\n    cmap: str = \"viridis\",\n):\n    c = len(feature_maps)\n    n_cols = min(c, max_cols)\n    n_rows = math.ceil(c / n_cols)\n    fig_size = (figsize_per_plot * n_cols, figsize_per_plot * n_rows)\n\n    fig, axes = plt.subplots(n_rows, n_cols, figsize=fig_size, squeeze=False, frameon=False)\n    fig.subplots_adjust(wspace=0.03, hspace=0.20, top=0.85)\n\n    # if title:\n    #    fig.suptitle(title, color=\"0.5\")\n\n    for ax in axes.flat:\n        ax.axis(\"off\")\n\n    for ax, (layer, feature_map) in zip(axes.flat, feature_maps.items(), strict=False):\n        rgb_features = pca_rgb(feature_map, n_components=n_components)\n        rgb_features = rgb_features.transpose(1, 2, 0)\n        rgb_features = rgb_features.squeeze()\n\n        ax.imshow(rgb_features, cmap=cmap, norm=norm, aspect=\"equal\", interpolation=\"none\")\n        if subtitles:\n            ax.set_title(layer, color=\"0.5\")\n\n    return fig, axes"
  },
  {
    "objectID": "posts/2025-05-06-feature-maps/index.html#prerequisites",
    "href": "posts/2025-05-06-feature-maps/index.html#prerequisites",
    "title": "Visualizing Feature Maps from VGG16 and ResNet50 in PyTorch",
    "section": "",
    "text": "Before we start, we need to install the following libraries: NumPy, Matplotlib, PyTorch, and Torchvision.\n\nimport math\nfrom collections.abc import Callable\nfrom pathlib import Path\nfrom typing import Literal\n\nimport numpy as np\nimport torch\nfrom IPython.display import Markdown\nfrom matplotlib import pyplot as plt\nfrom sklearn.decomposition import PCA\nfrom torch import Tensor, nn\nfrom torchvision import models\nfrom torchvision.io import decode_image\nfrom torchvision.transforms import v2 as T\n\nIn this article, we are going to use pre-trained neural networks. More specifically, weights trained on ImageNet-1K dataset.\nBut before that, we will prepare input images. We will size the image(s) to 224x224 and normalize it for optimal performance. The preparation step will make the pictures similar to the training dataset. See the link for more details on why this step is necessary.\n\n# ImageNet normalization weights per channel\nIMAGENET1K_MEAN = [0.485, 0.456, 0.406]\nIMAGENET1K_STD = [0.229, 0.224, 0.225]\n\ntransform = T.Compose(\n    [\n        T.Resize(256),\n        T.CenterCrop(224),\n        T.ToImage(),\n        T.ToDtype(torch.float32, scale=True),\n        T.Normalize(IMAGENET1K_MEAN, IMAGENET1K_STD),\n    ]\n)\n\n\ndef load_image(path: str | Path) -&gt; Tensor:\n    img = decode_image(str(path))\n\n    # Transform images into tensors\n    img: Tensor = transform(img)\n\n    # Add dimension to imitate batch size equal to 1: (C,H,W) -&gt; (B,C,H,W)\n    img = img.unsqueeze(0)\n    return img\n\n\ndef inverse_normalize(\n    x_norm: Tensor,\n    mean: list[float] = IMAGENET1K_MEAN,\n    std: list[float] = IMAGENET1K_STD,\n) -&gt; Tensor:\n    # Ensure mean and std have the correct shape\n    _mean = torch.as_tensor(mean).to(x_norm.device).view(1, -1, 1, 1)\n    _std = torch.as_tensor(std).to(x_norm.device).view(1, -1, 1, 1)\n    # Inverse normalization: x = x_normalized * std + mean\n    return x_norm.mul(_std).add(_mean)\n\n\nreverse_transform = T.Compose(\n    [\n        T.Lambda(inverse_normalize),\n        T.Lambda(lambda x: torch.clamp(x, min=0.0, max=1.0)),\n    ]\n)\n\n\nsample = load_image(\"bridge.jpg\")\norig_sample = reverse_transform(sample)\n\nfig, ax = plt.subplots(frameon=False)\nfig.subplots_adjust()\nax.imshow(orig_sample.squeeze(0).permute(1, 2, 0))\nax.axis(\"off\")\nplt.show()\n\n\n\n\nOriginal image, resized\n\n\n\n\n\ndef get_activation(name: str, activations: dict[str, Tensor]) -&gt; Callable:\n    def hook(model: nn.Module, tensor: Tensor, output: Tensor) -&gt; None:\n        # map layer's `name` to layer's output value\n        activations[name] = output.detach()\n\n    return hook\n\n\ndef set_hooks(model: nn.Module, layer_ids: list[str], out: dict[str, Tensor]) -&gt; None:\n    layer_ids = [str(i) for i in layer_ids]\n    for name, module in model.named_modules():\n        if name in layer_ids:\n            module.register_forward_hook(get_activation(name, out))\n\n\ndef visualize_feature_maps(\n    feature_map: Tensor | np.ndarray,\n    max_maps: int | None = None,\n    max_cols: int = 8,\n    figsize_per_plot: float = 1.0,\n    norm: Literal[\"linear\", \"log\", \"symlog\", \"logit\", None] = None,\n    cmap: str = \"viridis\",\n):\n    if isinstance(feature_map, Tensor):\n        feature_map = feature_map.cpu().numpy()\n\n    if feature_map.ndim == 4:\n        feature_map = feature_map.squeeze(0)  # remove batch dimension if present\n    assert feature_map.ndim == 3, \"Expected tensor shape (C, H, W)\"\n\n    C, H, W = feature_map.shape\n\n    if max_maps:\n        C = min(C, max_maps)\n\n    n_cols = min(C, max_cols)\n    n_rows = math.ceil(C / n_cols)\n\n    figsize = (figsize_per_plot * n_cols, figsize_per_plot * n_rows)\n\n    fig, axes = plt.subplots(nrows=n_rows, ncols=n_cols, figsize=figsize, frameon=False, squeeze=False)\n    fig.subplots_adjust(wspace=0.03, hspace=0.03)\n\n    for ax in axes.flat:\n        ax.axis(\"off\")\n\n    for i in range(C):\n        t = feature_map[i]\n        axes.flat[i].imshow(t, cmap=cmap, norm=norm, aspect=\"equal\", interpolation=\"none\")\n\n    return fig, axes\n\n\ndef minmax_scale_per_channel(arr: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Per-channel MinMax normalization. Expects (C, W, H).\"\"\"\n    assert arr.ndim == 3, f\"{arr.ndim=}\"\n\n    c_min = arr.min(axis=(1, 2), keepdims=True)\n    c_max = arr.max(axis=(1, 2), keepdims=True)\n    eps = 1e-5\n    scaled = (arr - c_min) / (c_max - c_min + eps)  # avoid division by zero\n    return scaled\n\n\ndef pca_rgb(\n    feature_map: np.ndarray | Tensor,\n    n_components: Literal[1, 3] = 3,\n    normalize: bool = True,\n    random_state: int | None = None,\n) -&gt; np.ndarray:\n    if isinstance(feature_map, torch.Tensor):\n        feature_map = feature_map.cpu().numpy()\n\n    if feature_map.ndim == 4:\n        feature_map = feature_map.squeeze(0)  # remove batch dimension if present\n    assert feature_map.ndim == 3, \"Expected array shape (C, H, W)\"\n\n    C, H, W = feature_map.shape\n    pca = PCA(n_components=n_components, random_state=random_state)\n    flat = feature_map.reshape(C, -1).T\n    rgb = pca.fit_transform(flat).T.reshape(n_components, H, W)\n\n    if normalize:\n        rgb = minmax_scale_per_channel(rgb)\n\n    return rgb\n\n\ndef visualize_feature_maps_pca(\n    feature_maps: dict[str, Tensor],\n    n_components: Literal[1, 3] = 3,\n    max_cols: int = 4,\n    figsize_per_plot: float = 2.0,\n    norm: Literal[\"linear\", \"log\", \"symlog\", \"logit\", None] = None,\n    subtitles: bool = True,\n    cmap: str = \"viridis\",\n):\n    c = len(feature_maps)\n    n_cols = min(c, max_cols)\n    n_rows = math.ceil(c / n_cols)\n    fig_size = (figsize_per_plot * n_cols, figsize_per_plot * n_rows)\n\n    fig, axes = plt.subplots(n_rows, n_cols, figsize=fig_size, squeeze=False, frameon=False)\n    fig.subplots_adjust(wspace=0.03, hspace=0.20, top=0.85)\n\n    # if title:\n    #    fig.suptitle(title, color=\"0.5\")\n\n    for ax in axes.flat:\n        ax.axis(\"off\")\n\n    for ax, (layer, feature_map) in zip(axes.flat, feature_maps.items(), strict=False):\n        rgb_features = pca_rgb(feature_map, n_components=n_components)\n        rgb_features = rgb_features.transpose(1, 2, 0)\n        rgb_features = rgb_features.squeeze()\n\n        ax.imshow(rgb_features, cmap=cmap, norm=norm, aspect=\"equal\", interpolation=\"none\")\n        if subtitles:\n            ax.set_title(layer, color=\"0.5\")\n\n    return fig, axes"
  },
  {
    "objectID": "posts/2025-05-06-feature-maps/index.html#vgg",
    "href": "posts/2025-05-06-feature-maps/index.html#vgg",
    "title": "Visualizing Feature Maps from VGG16 and ResNet50 in PyTorch",
    "section": "VGG",
    "text": "VGG\nThe VGG are deep neural networks introduced by (Simonyan and Zisserman 2014) in 2014. The VGG stacks many small 3x3 convolution filters in sequence. This simple “deeper‑is‑better” design once achieved top ImageNet performance while showing that depth and uniform layer structure can yield strong feature hierarchies, making VGG a popular baseline for vision tasks and transfer learning. Nowadays, they are considered outdated.\n\nmodel = models.vgg11(weights=models.VGG11_Weights.IMAGENET1K_V1).features\n\n# Let's inspect the VGG's feature extractor layers\nmodel\n\nSequential(\n  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n  (1): ReLU(inplace=True)\n  (2): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)\n  (3): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n  (4): ReLU(inplace=True)\n  (5): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)\n  (6): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n  (7): ReLU(inplace=True)\n  (8): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n  (9): ReLU(inplace=True)\n  (10): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)\n  (11): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n  (12): ReLU(inplace=True)\n  (13): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n  (14): ReLU(inplace=True)\n  (15): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)\n  (16): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n  (17): ReLU(inplace=True)\n  (18): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n  (19): ReLU(inplace=True)\n  (20): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)\n)\n\n\n\n# cherry-pick layers of which outputs we want to see\nselected_layers = [\"0\", \"3\", \"6\", \"8\", \"11\", \"13\", \"16\", \"18\"]\n\n# add forward hooks to the model\nvgg_activations = {}\nset_hooks(model, selected_layers, vgg_activations)\n\n# make forward pass through NN\nwith torch.no_grad():\n    model(sample)\n\nBelow we visualize the feature maps generated by a few hand‑picked layers. A feature map (also called an activation map) is simply the tensor that a layer outputs (for example, output = conv(input)). During training, each convolutional layer learns a set of spatial kernels that act as filters (see kernels in image processing), allowing the network to draw ever‑richer patterns from the feature maps produced by the preceding layers.\n\nfor layer, filters in vgg_activations.items():\n    display(Markdown(f\"### Layer #{layer}\"))\n    visualize_feature_maps(filters, max_maps=8 * 8, norm=\"linear\")\n    plt.show()\n\nLayer #0\n\n\n\n\n\n\n\n\n\nLayer #3\n\n\n\n\n\n\n\n\n\nLayer #6\n\n\n\n\n\n\n\n\n\nLayer #8\n\n\n\n\n\n\n\n\n\nLayer #11\n\n\n\n\n\n\n\n\n\nLayer #13\n\n\n\n\n\n\n\n\n\nLayer #16\n\n\n\n\n\n\n\n\n\nLayer #18\n\n\n\n\n\n\n\n\n\nAbove, we noted that the number of visualizations grows with the number of filters. A large number of filters can be overwhelming when a layer produces dozens of maps. To condense this information, we can project the feature maps with principal‑component analysis (PCA). We treat each spatial position across all maps as a feature vector, run PCA, and then reconstruct the dominant components. The result is a single “average” activation image that captures the most salient variance across the entire stack of feature maps. It can be rendered in either 1‑channel (grayscale) or 3‑channel (RGB) form.\n\nvisualize_feature_maps_pca(vgg_activations, max_cols=4)\nplt.show()\n\n\n\n\nPrincipal‑component projections of the feature‑map stacks for the corresponding layers of VGG‑11."
  },
  {
    "objectID": "posts/2025-05-06-feature-maps/index.html#resnet",
    "href": "posts/2025-05-06-feature-maps/index.html#resnet",
    "title": "Visualizing Feature Maps from VGG16 and ResNet50 in PyTorch",
    "section": "ResNet",
    "text": "ResNet\nResNets (Residual Networks), introduced by (Targ, Almeida, and Lyman 2016), add “skip” or residual connections that let inputs bypass one or more layers. These identity shortcuts make very deep CNNs (e.g., ResNet‑50/101/152) easier to train by mitigating vanishing gradients, enabling state‑of‑the‑art accuracy with hundreds of layers. [wiki]\n\nmodel = models.resnet50(weights=models.ResNet50_Weights.IMAGENET1K_V1)\n\n# inspect layers within ResNet\nmodel\n\nResNet(\n  (conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)\n  (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n  (relu): ReLU(inplace=True)\n  (maxpool): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False)\n  (layer1): Sequential(\n    (0): Bottleneck(\n      (conv1): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n      (downsample): Sequential(\n        (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n        (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n    )\n    (1): Bottleneck(\n      (conv1): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n    )\n    (2): Bottleneck(\n      (conv1): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n    )\n  )\n  (layer2): Sequential(\n    (0): Bottleneck(\n      (conv1): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n      (downsample): Sequential(\n        (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)\n        (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n    )\n    (1): Bottleneck(\n      (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n    )\n    (2): Bottleneck(\n      (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n    )\n    (3): Bottleneck(\n      (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n    )\n  )\n  (layer3): Sequential(\n    (0): Bottleneck(\n      (conv1): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n      (downsample): Sequential(\n        (0): Conv2d(512, 1024, kernel_size=(1, 1), stride=(2, 2), bias=False)\n        (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n    )\n    (1): Bottleneck(\n      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n    )\n    (2): Bottleneck(\n      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n    )\n    (3): Bottleneck(\n      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n    )\n    (4): Bottleneck(\n      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n    )\n    (5): Bottleneck(\n      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n    )\n  )\n  (layer4): Sequential(\n    (0): Bottleneck(\n      (conv1): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n      (downsample): Sequential(\n        (0): Conv2d(1024, 2048, kernel_size=(1, 1), stride=(2, 2), bias=False)\n        (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n    )\n    (1): Bottleneck(\n      (conv1): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n    )\n    (2): Bottleneck(\n      (conv1): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)\n      (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n    )\n  )\n  (avgpool): AdaptiveAvgPool2d(output_size=(1, 1))\n  (fc): Linear(in_features=2048, out_features=1000, bias=True)\n)\n\n\n\nselected_layers = [\"conv1\", \"layer1\", \"layer2\", \"layer3\", \"layer4\"]\nresnet_feature_maps: dict[str, Tensor] = {}\nset_hooks(model, selected_layers, resnet_feature_maps)\n\nwith torch.no_grad():\n    model(sample)\n\n\nfor layer, filters in resnet_feature_maps.items():\n    display(Markdown(f'### Layer \"{layer}\"'))\n    visualize_feature_maps(filters, max_maps=8 * 8, norm=\"linear\")\n    plt.show()\n\nLayer “conv1”\n\n\n\n\n\n\n\n\n\nLayer “layer1”\n\n\n\n\n\n\n\n\n\nLayer “layer2”\n\n\n\n\n\n\n\n\n\nLayer “layer3”\n\n\n\n\n\n\n\n\n\nLayer “layer4”\n\n\n\n\n\n\n\n\n\n\nvisualize_feature_maps_pca(resnet_feature_maps, max_cols=3)\nplt.show()\n\n\n\n\nPrincipal‑component projections of the feature‑map stacks for the corresponding layers of ResNet-50."
  },
  {
    "objectID": "posts/2025-05-06-feature-maps/index.html#conclusions",
    "href": "posts/2025-05-06-feature-maps/index.html#conclusions",
    "title": "Visualizing Feature Maps from VGG16 and ResNet50 in PyTorch",
    "section": "Conclusions",
    "text": "Conclusions\nThis article introduced a lightweight technique for visualizing pre-selected neural network layers’ feature maps (layer‑wise outputs). These visualizations offer an intuitive window into what a convolutional network attends to at each processing stage.\nFor deeper, production‑grade interpretability, explore the rich ecosystem of explainability libraries and frameworks, such as Captum or SHAP, and take a broader look at the rapidly growing fields of eXplainable AI (XAI) and Responsible AI.\n\nCaptum\nSHAP"
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-17-tabular-q-learning.html",
    "href": "posts/reinforcement-learning/2025-12-17-tabular-q-learning.html",
    "title": "Reinforcement Learning: Tabular Q-Learning",
    "section": "",
    "text": "As I started exploring reinforcement learning, a colleague suggested me to start with a Q-learning, one of the simplest and most widely used algorithms in the field. To get a hands-on feel for the fundamentals, I decided to replicate the official Solving Frozenlake with Tabular Q-Learning tutorial from the Gymnasium docs.\nThis post captures that learning journey: walking through the environment, understanding the Q-learning steps, and getting comfortable with Gymnasium library along the way."
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-17-tabular-q-learning.html#action-space",
    "href": "posts/reinforcement-learning/2025-12-17-tabular-q-learning.html#action-space",
    "title": "Reinforcement Learning: Tabular Q-Learning",
    "section": "Action Space",
    "text": "Action Space\nThe action space is simple and discrete. At each timestep, the agent can choose one of four actions:\n\nmove left,\nmove right,\nmove down,\nmove up.\n\nFormally, the action is represented as a scalar with shape \\((1,)\\), taking values from the set \\(\\{ 0, 1, 2, 3 \\}\\).\nThis representation is a general abstraction used throughout Gymnasium. In more complex environments, a single action may encode multiple simultaneous commands. For example, in a game like Super Mario, a player can jump while moving left or right. Such combinations are still treated as a single action by the environment."
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-17-tabular-q-learning.html#observation-space",
    "href": "posts/reinforcement-learning/2025-12-17-tabular-q-learning.html#observation-space",
    "title": "Reinforcement Learning: Tabular Q-Learning",
    "section": "Observation Space",
    "text": "Observation Space\nThe observation returned by the environment represents the agent’s current position on the grid. Since Frozen Lake consists of a finite number of discrete tiles, each tile is assigned a unique integer identifier.\nFor example, a \\(3\\times{}3\\) grid is indexed as:\n\\[\n\\begin{matrix}\n0 & 1 & 2 \\\\\n3 & 4 & 5 \\\\\n6 & 7 & 8\n\\end{matrix}\n\\]\nMore generally, the tile index can be computed as:\n\\[\n\\text{tile}(r,c) = r \\cdot N_{\\text{cols}} + c,\n\\]\nwhere:\n\nwhere \\(r\\) is row index,\n\\(c\\) is column index,\n\\(N_{\\text{cols}}\\) is number of columns in grid.\n\nThis discrete state representation makes Frozen Lake particularly well-suited for tabular methods such as Q-learning."
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-17-tabular-q-learning.html#rewards",
    "href": "posts/reinforcement-learning/2025-12-17-tabular-q-learning.html#rewards",
    "title": "Reinforcement Learning: Tabular Q-Learning",
    "section": "Rewards",
    "text": "Rewards\nThe default reward structure is sparse:\n\n\\(+1\\) for reaching the goal tile,\n\\(0\\) for stepping onto a frozen tile,\n\\(0\\) for falling into a hole.\n\nIn other words, the agent receives a reward only when it successfully reaches the goal. This sparse reward setting makes the problem deceptively challenging and highlights the importance of exploration in reinforcement learning.\nFor full details, see the official Frozen Lake environment documentation."
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-17-tabular-q-learning.html#state-space-mathcals",
    "href": "posts/reinforcement-learning/2025-12-17-tabular-q-learning.html#state-space-mathcals",
    "title": "Reinforcement Learning: Tabular Q-Learning",
    "section": "State Space \\(\\mathcal{S}\\)",
    "text": "State Space \\(\\mathcal{S}\\)\nThe state space consists of all discrete tiles on the grid:\n\\[\n\\mathcal{S} = \\{ 0, 1, \\dots, (N_\\text{rows}\\cdot{}N_\\text{cols}-1) \\}.\n\\]\nEach state uniquely represents the agent’s current position in the lake."
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-17-tabular-q-learning.html#action-space-mathcala",
    "href": "posts/reinforcement-learning/2025-12-17-tabular-q-learning.html#action-space-mathcala",
    "title": "Reinforcement Learning: Tabular Q-Learning",
    "section": "Action Space \\(\\mathcal{A}\\)",
    "text": "Action Space \\(\\mathcal{A}\\)\nAt each time step, the agent can choose one of four actions:\n\\[\n\\mathcal{A} = \\{ \\text{left}, \\text{down}, \\text{right}, \\text{up} \\}.\n\\]\nThese actions correspond to deterministic intentions, even though the actual transition may be stochastic when the lake is slippery."
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-17-tabular-q-learning.html#transition-dynamics-pssa",
    "href": "posts/reinforcement-learning/2025-12-17-tabular-q-learning.html#transition-dynamics-pssa",
    "title": "Reinforcement Learning: Tabular Q-Learning",
    "section": "Transition Dynamics \\(P(s'|s,a)\\)",
    "text": "Transition Dynamics \\(P(s'|s,a)\\)\nThe transition function defines the probability of moving from state \\(s\\) to state \\(s'\\) after taking action \\(a\\).\n\nIn the non-slippery version of the environment, transitions are deterministic.\nIn the slippery version, the intended action may fail, and the agent may move in a perpendicular direction with non-zero probability.\n\nThis stochasticity makes Frozen Lake a useful testbed for algorithms that must learn under uncertainty."
  },
  {
    "objectID": "posts/reinforcement-learning/2025-12-17-tabular-q-learning.html#reward-function-rs-a-s",
    "href": "posts/reinforcement-learning/2025-12-17-tabular-q-learning.html#reward-function-rs-a-s",
    "title": "Reinforcement Learning: Tabular Q-Learning",
    "section": "Reward Function \\(R(s, a, s')\\)",
    "text": "Reward Function \\(R(s, a, s')\\)\nThe reward function is sparse and simple:\n\\[\nR(s, a, s') = \\begin{cases}\n    1, & \\text{if $s'$ is the goal state},\\\\\n    0, & \\text{otherwise}.\n\\end{cases}\n\\]\nEpisodes terminate when the agent reaches the goal or falls into a hole.\n\nimport os\n\n# get rid of the audio warnings\nos.environ[\"SDL_AUDIODRIVER\"] = \"dummy\"\n\n\nfrom dataclasses import dataclass\n\nimport gymnasium as gym\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom aquarel import load_theme\nfrom gymnasium.envs.toy_text.frozen_lake import generate_random_map\nfrom tqdm.auto import tqdm, trange\n\n%config InlineBackend.figure_formats = {'retina', 'png'}\n\n\n@dataclass(frozen=True, slots=True)\nclass Params:\n    n_runs: int = 20  # number of runs from scratch\n    total_episodes: int = 2_000  # total episodes (# of playthroughs) in the same run\n    learning_rate: float = 0.8  # Q-Learning learning rate\n    gamma: float = 0.95  # discounting rate\n    epsilon: float = 0.1  # probability of exploration vs. exploitation\n    proba_frozen: float = 0.9  # probability that a tile is frozen (not a hole)\n    is_slippery: bool = False  # enables slipping: 1/3 forward, 1/3 left, 1/3 right\n    seed: int = 123  # seed for reproducability\n\n\nSHOW_PROGRESS: bool = False"
  }
]